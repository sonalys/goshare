// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package application

import (
	"context"
	"sync"
	"time"

	"github.com/sonalys/goshare/internal/application"
	"github.com/sonalys/goshare/internal/application/pkg/v1"
	"github.com/sonalys/goshare/internal/domain"
)

// Ensure that MockLedgerQueries does implement application.LedgerQueries.
// If this is not the case, regenerate this file with mockery.
var _ application.LedgerQueries = &MockLedgerQueries{}

// MockLedgerQueries is a mock implementation of application.LedgerQueries.
//
//	func TestSomethingThatUsesLedgerQueries(t *testing.T) {
//
//		// make and configure a mocked application.LedgerQueries
//		mockedLedgerQueries := &MockLedgerQueries{
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
//				panic("mock out the Find method")
//			},
//			GetByUserFunc: func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
//				panic("mock out the GetByUser method")
//			},
//		}
//
//		// use mockedLedgerQueries in code that requires application.LedgerQueries
//		// and then make assertions.
//
//	}
type MockLedgerQueries struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.Ledger, error)

	// GetByUserFunc mocks the GetByUser method.
	GetByUserFunc func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error)

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// GetByUser holds details about calls to the GetByUser method.
		GetByUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Identity is the identity argument value.
			Identity domain.ID
		}
	}
	lockFind      sync.RWMutex
	lockGetByUser sync.RWMutex
}

// Find calls FindFunc.
func (mock *MockLedgerQueries) Find(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
	if mock.FindFunc == nil {
		panic("MockLedgerQueries.FindFunc: method is nil but LedgerQueries.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedLedgerQueries.FindCalls())
func (mock *MockLedgerQueries) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// GetByUser calls GetByUserFunc.
func (mock *MockLedgerQueries) GetByUser(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
	if mock.GetByUserFunc == nil {
		panic("MockLedgerQueries.GetByUserFunc: method is nil but LedgerQueries.GetByUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Identity domain.ID
	}{
		Ctx:      ctx,
		Identity: identity,
	}
	mock.lockGetByUser.Lock()
	mock.calls.GetByUser = append(mock.calls.GetByUser, callInfo)
	mock.lockGetByUser.Unlock()
	return mock.GetByUserFunc(ctx, identity)
}

// GetByUserCalls gets all the calls that were made to GetByUser.
// Check the length with:
//
//	len(mockedLedgerQueries.GetByUserCalls())
func (mock *MockLedgerQueries) GetByUserCalls() []struct {
	Ctx      context.Context
	Identity domain.ID
} {
	var calls []struct {
		Ctx      context.Context
		Identity domain.ID
	}
	mock.lockGetByUser.RLock()
	calls = mock.calls.GetByUser
	mock.lockGetByUser.RUnlock()
	return calls
}

// Ensure that MockLedgerCommands does implement application.LedgerCommands.
// If this is not the case, regenerate this file with mockery.
var _ application.LedgerCommands = &MockLedgerCommands{}

// MockLedgerCommands is a mock implementation of application.LedgerCommands.
//
//	func TestSomethingThatUsesLedgerCommands(t *testing.T) {
//
//		// make and configure a mocked application.LedgerCommands
//		mockedLedgerCommands := &MockLedgerCommands{
//			CreateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Create method")
//			},
//			UpdateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedLedgerCommands in code that requires application.LedgerCommands
//		// and then make assertions.
//
//	}
type MockLedgerCommands struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
	}
	lockCreate sync.RWMutex
	lockUpdate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *MockLedgerCommands) Create(ctx context.Context, ledger *domain.Ledger) error {
	if mock.CreateFunc == nil {
		panic("MockLedgerCommands.CreateFunc: method is nil but LedgerCommands.Create was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledger)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedLedgerCommands.CreateCalls())
func (mock *MockLedgerCommands) CreateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *MockLedgerCommands) Update(ctx context.Context, ledger *domain.Ledger) error {
	if mock.UpdateFunc == nil {
		panic("MockLedgerCommands.UpdateFunc: method is nil but LedgerCommands.Update was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, ledger)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedLedgerCommands.UpdateCalls())
func (mock *MockLedgerCommands) UpdateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that MockLedgerRepository does implement application.LedgerRepository.
// If this is not the case, regenerate this file with mockery.
var _ application.LedgerRepository = &MockLedgerRepository{}

// MockLedgerRepository is a mock implementation of application.LedgerRepository.
//
//	func TestSomethingThatUsesLedgerRepository(t *testing.T) {
//
//		// make and configure a mocked application.LedgerRepository
//		mockedLedgerRepository := &MockLedgerRepository{
//			CreateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Create method")
//			},
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
//				panic("mock out the Find method")
//			},
//			GetByUserFunc: func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
//				panic("mock out the GetByUser method")
//			},
//			UpdateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedLedgerRepository in code that requires application.LedgerRepository
//		// and then make assertions.
//
//	}
type MockLedgerRepository struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.Ledger, error)

	// GetByUserFunc mocks the GetByUser method.
	GetByUserFunc func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// GetByUser holds details about calls to the GetByUser method.
		GetByUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Identity is the identity argument value.
			Identity domain.ID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
	}
	lockCreate    sync.RWMutex
	lockFind      sync.RWMutex
	lockGetByUser sync.RWMutex
	lockUpdate    sync.RWMutex
}

// Create calls CreateFunc.
func (mock *MockLedgerRepository) Create(ctx context.Context, ledger *domain.Ledger) error {
	if mock.CreateFunc == nil {
		panic("MockLedgerRepository.CreateFunc: method is nil but LedgerRepository.Create was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledger)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedLedgerRepository.CreateCalls())
func (mock *MockLedgerRepository) CreateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Find calls FindFunc.
func (mock *MockLedgerRepository) Find(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
	if mock.FindFunc == nil {
		panic("MockLedgerRepository.FindFunc: method is nil but LedgerRepository.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedLedgerRepository.FindCalls())
func (mock *MockLedgerRepository) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// GetByUser calls GetByUserFunc.
func (mock *MockLedgerRepository) GetByUser(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
	if mock.GetByUserFunc == nil {
		panic("MockLedgerRepository.GetByUserFunc: method is nil but LedgerRepository.GetByUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Identity domain.ID
	}{
		Ctx:      ctx,
		Identity: identity,
	}
	mock.lockGetByUser.Lock()
	mock.calls.GetByUser = append(mock.calls.GetByUser, callInfo)
	mock.lockGetByUser.Unlock()
	return mock.GetByUserFunc(ctx, identity)
}

// GetByUserCalls gets all the calls that were made to GetByUser.
// Check the length with:
//
//	len(mockedLedgerRepository.GetByUserCalls())
func (mock *MockLedgerRepository) GetByUserCalls() []struct {
	Ctx      context.Context
	Identity domain.ID
} {
	var calls []struct {
		Ctx      context.Context
		Identity domain.ID
	}
	mock.lockGetByUser.RLock()
	calls = mock.calls.GetByUser
	mock.lockGetByUser.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *MockLedgerRepository) Update(ctx context.Context, ledger *domain.Ledger) error {
	if mock.UpdateFunc == nil {
		panic("MockLedgerRepository.UpdateFunc: method is nil but LedgerRepository.Update was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, ledger)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedLedgerRepository.UpdateCalls())
func (mock *MockLedgerRepository) UpdateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that MockUserQueries does implement application.UserQueries.
// If this is not the case, regenerate this file with mockery.
var _ application.UserQueries = &MockUserQueries{}

// MockUserQueries is a mock implementation of application.UserQueries.
//
//	func TestSomethingThatUsesUserQueries(t *testing.T) {
//
//		// make and configure a mocked application.UserQueries
//		mockedUserQueries := &MockUserQueries{
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.User, error) {
//				panic("mock out the Find method")
//			},
//			FindByEmailFunc: func(ctx context.Context, email string) (*domain.User, error) {
//				panic("mock out the FindByEmail method")
//			},
//			ListByEmailFunc: func(ctx context.Context, emails []string) ([]domain.User, error) {
//				panic("mock out the ListByEmail method")
//			},
//		}
//
//		// use mockedUserQueries in code that requires application.UserQueries
//		// and then make assertions.
//
//	}
type MockUserQueries struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.User, error)

	// FindByEmailFunc mocks the FindByEmail method.
	FindByEmailFunc func(ctx context.Context, email string) (*domain.User, error)

	// ListByEmailFunc mocks the ListByEmail method.
	ListByEmailFunc func(ctx context.Context, emails []string) ([]domain.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// FindByEmail holds details about calls to the FindByEmail method.
		FindByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// ListByEmail holds details about calls to the ListByEmail method.
		ListByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Emails is the emails argument value.
			Emails []string
		}
	}
	lockFind        sync.RWMutex
	lockFindByEmail sync.RWMutex
	lockListByEmail sync.RWMutex
}

// Find calls FindFunc.
func (mock *MockUserQueries) Find(ctx context.Context, id domain.ID) (*domain.User, error) {
	if mock.FindFunc == nil {
		panic("MockUserQueries.FindFunc: method is nil but UserQueries.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedUserQueries.FindCalls())
func (mock *MockUserQueries) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// FindByEmail calls FindByEmailFunc.
func (mock *MockUserQueries) FindByEmail(ctx context.Context, email string) (*domain.User, error) {
	if mock.FindByEmailFunc == nil {
		panic("MockUserQueries.FindByEmailFunc: method is nil but UserQueries.FindByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockFindByEmail.Lock()
	mock.calls.FindByEmail = append(mock.calls.FindByEmail, callInfo)
	mock.lockFindByEmail.Unlock()
	return mock.FindByEmailFunc(ctx, email)
}

// FindByEmailCalls gets all the calls that were made to FindByEmail.
// Check the length with:
//
//	len(mockedUserQueries.FindByEmailCalls())
func (mock *MockUserQueries) FindByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockFindByEmail.RLock()
	calls = mock.calls.FindByEmail
	mock.lockFindByEmail.RUnlock()
	return calls
}

// ListByEmail calls ListByEmailFunc.
func (mock *MockUserQueries) ListByEmail(ctx context.Context, emails []string) ([]domain.User, error) {
	if mock.ListByEmailFunc == nil {
		panic("MockUserQueries.ListByEmailFunc: method is nil but UserQueries.ListByEmail was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Emails []string
	}{
		Ctx:    ctx,
		Emails: emails,
	}
	mock.lockListByEmail.Lock()
	mock.calls.ListByEmail = append(mock.calls.ListByEmail, callInfo)
	mock.lockListByEmail.Unlock()
	return mock.ListByEmailFunc(ctx, emails)
}

// ListByEmailCalls gets all the calls that were made to ListByEmail.
// Check the length with:
//
//	len(mockedUserQueries.ListByEmailCalls())
func (mock *MockUserQueries) ListByEmailCalls() []struct {
	Ctx    context.Context
	Emails []string
} {
	var calls []struct {
		Ctx    context.Context
		Emails []string
	}
	mock.lockListByEmail.RLock()
	calls = mock.calls.ListByEmail
	mock.lockListByEmail.RUnlock()
	return calls
}

// Ensure that MockUserCommands does implement application.UserCommands.
// If this is not the case, regenerate this file with mockery.
var _ application.UserCommands = &MockUserCommands{}

// MockUserCommands is a mock implementation of application.UserCommands.
//
//	func TestSomethingThatUsesUserCommands(t *testing.T) {
//
//		// make and configure a mocked application.UserCommands
//		mockedUserCommands := &MockUserCommands{
//			SaveFunc: func(ctx context.Context, user *domain.User) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedUserCommands in code that requires application.UserCommands
//		// and then make assertions.
//
//	}
type MockUserCommands struct {
	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, user *domain.User) error

	// calls tracks calls to the methods.
	calls struct {
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User *domain.User
		}
	}
	lockSave sync.RWMutex
}

// Save calls SaveFunc.
func (mock *MockUserCommands) Save(ctx context.Context, user *domain.User) error {
	if mock.SaveFunc == nil {
		panic("MockUserCommands.SaveFunc: method is nil but UserCommands.Save was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User *domain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, user)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedUserCommands.SaveCalls())
func (mock *MockUserCommands) SaveCalls() []struct {
	Ctx  context.Context
	User *domain.User
} {
	var calls []struct {
		Ctx  context.Context
		User *domain.User
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure that MockUserRepository does implement application.UserRepository.
// If this is not the case, regenerate this file with mockery.
var _ application.UserRepository = &MockUserRepository{}

// MockUserRepository is a mock implementation of application.UserRepository.
//
//	func TestSomethingThatUsesUserRepository(t *testing.T) {
//
//		// make and configure a mocked application.UserRepository
//		mockedUserRepository := &MockUserRepository{
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.User, error) {
//				panic("mock out the Find method")
//			},
//			FindByEmailFunc: func(ctx context.Context, email string) (*domain.User, error) {
//				panic("mock out the FindByEmail method")
//			},
//			ListByEmailFunc: func(ctx context.Context, emails []string) ([]domain.User, error) {
//				panic("mock out the ListByEmail method")
//			},
//			SaveFunc: func(ctx context.Context, user *domain.User) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedUserRepository in code that requires application.UserRepository
//		// and then make assertions.
//
//	}
type MockUserRepository struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.User, error)

	// FindByEmailFunc mocks the FindByEmail method.
	FindByEmailFunc func(ctx context.Context, email string) (*domain.User, error)

	// ListByEmailFunc mocks the ListByEmail method.
	ListByEmailFunc func(ctx context.Context, emails []string) ([]domain.User, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, user *domain.User) error

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// FindByEmail holds details about calls to the FindByEmail method.
		FindByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// ListByEmail holds details about calls to the ListByEmail method.
		ListByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Emails is the emails argument value.
			Emails []string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User *domain.User
		}
	}
	lockFind        sync.RWMutex
	lockFindByEmail sync.RWMutex
	lockListByEmail sync.RWMutex
	lockSave        sync.RWMutex
}

// Find calls FindFunc.
func (mock *MockUserRepository) Find(ctx context.Context, id domain.ID) (*domain.User, error) {
	if mock.FindFunc == nil {
		panic("MockUserRepository.FindFunc: method is nil but UserRepository.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedUserRepository.FindCalls())
func (mock *MockUserRepository) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// FindByEmail calls FindByEmailFunc.
func (mock *MockUserRepository) FindByEmail(ctx context.Context, email string) (*domain.User, error) {
	if mock.FindByEmailFunc == nil {
		panic("MockUserRepository.FindByEmailFunc: method is nil but UserRepository.FindByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockFindByEmail.Lock()
	mock.calls.FindByEmail = append(mock.calls.FindByEmail, callInfo)
	mock.lockFindByEmail.Unlock()
	return mock.FindByEmailFunc(ctx, email)
}

// FindByEmailCalls gets all the calls that were made to FindByEmail.
// Check the length with:
//
//	len(mockedUserRepository.FindByEmailCalls())
func (mock *MockUserRepository) FindByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockFindByEmail.RLock()
	calls = mock.calls.FindByEmail
	mock.lockFindByEmail.RUnlock()
	return calls
}

// ListByEmail calls ListByEmailFunc.
func (mock *MockUserRepository) ListByEmail(ctx context.Context, emails []string) ([]domain.User, error) {
	if mock.ListByEmailFunc == nil {
		panic("MockUserRepository.ListByEmailFunc: method is nil but UserRepository.ListByEmail was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Emails []string
	}{
		Ctx:    ctx,
		Emails: emails,
	}
	mock.lockListByEmail.Lock()
	mock.calls.ListByEmail = append(mock.calls.ListByEmail, callInfo)
	mock.lockListByEmail.Unlock()
	return mock.ListByEmailFunc(ctx, emails)
}

// ListByEmailCalls gets all the calls that were made to ListByEmail.
// Check the length with:
//
//	len(mockedUserRepository.ListByEmailCalls())
func (mock *MockUserRepository) ListByEmailCalls() []struct {
	Ctx    context.Context
	Emails []string
} {
	var calls []struct {
		Ctx    context.Context
		Emails []string
	}
	mock.lockListByEmail.RLock()
	calls = mock.calls.ListByEmail
	mock.lockListByEmail.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *MockUserRepository) Save(ctx context.Context, user *domain.User) error {
	if mock.SaveFunc == nil {
		panic("MockUserRepository.SaveFunc: method is nil but UserRepository.Save was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User *domain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, user)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedUserRepository.SaveCalls())
func (mock *MockUserRepository) SaveCalls() []struct {
	Ctx  context.Context
	User *domain.User
} {
	var calls []struct {
		Ctx  context.Context
		User *domain.User
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure that MockExpenseQueries does implement application.ExpenseQueries.
// If this is not the case, regenerate this file with mockery.
var _ application.ExpenseQueries = &MockExpenseQueries{}

// MockExpenseQueries is a mock implementation of application.ExpenseQueries.
//
//	func TestSomethingThatUsesExpenseQueries(t *testing.T) {
//
//		// make and configure a mocked application.ExpenseQueries
//		mockedExpenseQueries := &MockExpenseQueries{
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.Expense, error) {
//				panic("mock out the Find method")
//			},
//			GetByLedgerFunc: func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
//				panic("mock out the GetByLedger method")
//			},
//		}
//
//		// use mockedExpenseQueries in code that requires application.ExpenseQueries
//		// and then make assertions.
//
//	}
type MockExpenseQueries struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.Expense, error)

	// GetByLedgerFunc mocks the GetByLedger method.
	GetByLedgerFunc func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error)

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// GetByLedger holds details about calls to the GetByLedger method.
		GetByLedger []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Cursor is the cursor argument value.
			Cursor time.Time
			// Limit is the limit argument value.
			Limit int32
		}
	}
	lockFind        sync.RWMutex
	lockGetByLedger sync.RWMutex
}

// Find calls FindFunc.
func (mock *MockExpenseQueries) Find(ctx context.Context, id domain.ID) (*domain.Expense, error) {
	if mock.FindFunc == nil {
		panic("MockExpenseQueries.FindFunc: method is nil but ExpenseQueries.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedExpenseQueries.FindCalls())
func (mock *MockExpenseQueries) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// GetByLedger calls GetByLedgerFunc.
func (mock *MockExpenseQueries) GetByLedger(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
	if mock.GetByLedgerFunc == nil {
		panic("MockExpenseQueries.GetByLedgerFunc: method is nil but ExpenseQueries.GetByLedger was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Cursor:   cursor,
		Limit:    limit,
	}
	mock.lockGetByLedger.Lock()
	mock.calls.GetByLedger = append(mock.calls.GetByLedger, callInfo)
	mock.lockGetByLedger.Unlock()
	return mock.GetByLedgerFunc(ctx, ledgerID, cursor, limit)
}

// GetByLedgerCalls gets all the calls that were made to GetByLedger.
// Check the length with:
//
//	len(mockedExpenseQueries.GetByLedgerCalls())
func (mock *MockExpenseQueries) GetByLedgerCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Cursor   time.Time
	Limit    int32
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}
	mock.lockGetByLedger.RLock()
	calls = mock.calls.GetByLedger
	mock.lockGetByLedger.RUnlock()
	return calls
}

// Ensure that MockExpenseCommands does implement application.ExpenseCommands.
// If this is not the case, regenerate this file with mockery.
var _ application.ExpenseCommands = &MockExpenseCommands{}

// MockExpenseCommands is a mock implementation of application.ExpenseCommands.
//
//	func TestSomethingThatUsesExpenseCommands(t *testing.T) {
//
//		// make and configure a mocked application.ExpenseCommands
//		mockedExpenseCommands := &MockExpenseCommands{
//			CreateFunc: func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
//				panic("mock out the Create method")
//			},
//			UpdateFunc: func(ctx context.Context, expense *domain.Expense) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedExpenseCommands in code that requires application.ExpenseCommands
//		// and then make assertions.
//
//	}
type MockExpenseCommands struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, expense *domain.Expense) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
	}
	lockCreate sync.RWMutex
	lockUpdate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *MockExpenseCommands) Create(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
	if mock.CreateFunc == nil {
		panic("MockExpenseCommands.CreateFunc: method is nil but ExpenseCommands.Create was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Expense:  expense,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledgerID, expense)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedExpenseCommands.CreateCalls())
func (mock *MockExpenseCommands) CreateCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Expense  *domain.Expense
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *MockExpenseCommands) Update(ctx context.Context, expense *domain.Expense) error {
	if mock.UpdateFunc == nil {
		panic("MockExpenseCommands.UpdateFunc: method is nil but ExpenseCommands.Update was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Expense *domain.Expense
	}{
		Ctx:     ctx,
		Expense: expense,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, expense)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedExpenseCommands.UpdateCalls())
func (mock *MockExpenseCommands) UpdateCalls() []struct {
	Ctx     context.Context
	Expense *domain.Expense
} {
	var calls []struct {
		Ctx     context.Context
		Expense *domain.Expense
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that MockExpenseRepository does implement application.ExpenseRepository.
// If this is not the case, regenerate this file with mockery.
var _ application.ExpenseRepository = &MockExpenseRepository{}

// MockExpenseRepository is a mock implementation of application.ExpenseRepository.
//
//	func TestSomethingThatUsesExpenseRepository(t *testing.T) {
//
//		// make and configure a mocked application.ExpenseRepository
//		mockedExpenseRepository := &MockExpenseRepository{
//			CreateFunc: func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
//				panic("mock out the Create method")
//			},
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.Expense, error) {
//				panic("mock out the Find method")
//			},
//			GetByLedgerFunc: func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
//				panic("mock out the GetByLedger method")
//			},
//			UpdateFunc: func(ctx context.Context, expense *domain.Expense) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedExpenseRepository in code that requires application.ExpenseRepository
//		// and then make assertions.
//
//	}
type MockExpenseRepository struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error

	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.Expense, error)

	// GetByLedgerFunc mocks the GetByLedger method.
	GetByLedgerFunc func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, expense *domain.Expense) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// GetByLedger holds details about calls to the GetByLedger method.
		GetByLedger []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Cursor is the cursor argument value.
			Cursor time.Time
			// Limit is the limit argument value.
			Limit int32
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
	}
	lockCreate      sync.RWMutex
	lockFind        sync.RWMutex
	lockGetByLedger sync.RWMutex
	lockUpdate      sync.RWMutex
}

// Create calls CreateFunc.
func (mock *MockExpenseRepository) Create(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
	if mock.CreateFunc == nil {
		panic("MockExpenseRepository.CreateFunc: method is nil but ExpenseRepository.Create was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Expense:  expense,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledgerID, expense)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedExpenseRepository.CreateCalls())
func (mock *MockExpenseRepository) CreateCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Expense  *domain.Expense
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Find calls FindFunc.
func (mock *MockExpenseRepository) Find(ctx context.Context, id domain.ID) (*domain.Expense, error) {
	if mock.FindFunc == nil {
		panic("MockExpenseRepository.FindFunc: method is nil but ExpenseRepository.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedExpenseRepository.FindCalls())
func (mock *MockExpenseRepository) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// GetByLedger calls GetByLedgerFunc.
func (mock *MockExpenseRepository) GetByLedger(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
	if mock.GetByLedgerFunc == nil {
		panic("MockExpenseRepository.GetByLedgerFunc: method is nil but ExpenseRepository.GetByLedger was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Cursor:   cursor,
		Limit:    limit,
	}
	mock.lockGetByLedger.Lock()
	mock.calls.GetByLedger = append(mock.calls.GetByLedger, callInfo)
	mock.lockGetByLedger.Unlock()
	return mock.GetByLedgerFunc(ctx, ledgerID, cursor, limit)
}

// GetByLedgerCalls gets all the calls that were made to GetByLedger.
// Check the length with:
//
//	len(mockedExpenseRepository.GetByLedgerCalls())
func (mock *MockExpenseRepository) GetByLedgerCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Cursor   time.Time
	Limit    int32
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}
	mock.lockGetByLedger.RLock()
	calls = mock.calls.GetByLedger
	mock.lockGetByLedger.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *MockExpenseRepository) Update(ctx context.Context, expense *domain.Expense) error {
	if mock.UpdateFunc == nil {
		panic("MockExpenseRepository.UpdateFunc: method is nil but ExpenseRepository.Update was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Expense *domain.Expense
	}{
		Ctx:     ctx,
		Expense: expense,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, expense)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedExpenseRepository.UpdateCalls())
func (mock *MockExpenseRepository) UpdateCalls() []struct {
	Ctx     context.Context
	Expense *domain.Expense
} {
	var calls []struct {
		Ctx     context.Context
		Expense *domain.Expense
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that MockDatabase does implement application.Database.
// If this is not the case, regenerate this file with mockery.
var _ application.Database = &MockDatabase{}

// MockDatabase is a mock implementation of application.Database.
//
//	func TestSomethingThatUsesDatabase(t *testing.T) {
//
//		// make and configure a mocked application.Database
//		mockedDatabase := &MockDatabase{
//			ExpenseFunc: func() application.ExpenseQueries {
//				panic("mock out the Expense method")
//			},
//			LedgerFunc: func() application.LedgerQueries {
//				panic("mock out the Ledger method")
//			},
//			TransactionFunc: func(ctx context.Context, f func(tx application.Repositories) error) error {
//				panic("mock out the Transaction method")
//			},
//			UserFunc: func() application.UserQueries {
//				panic("mock out the User method")
//			},
//		}
//
//		// use mockedDatabase in code that requires application.Database
//		// and then make assertions.
//
//	}
type MockDatabase struct {
	// ExpenseFunc mocks the Expense method.
	ExpenseFunc func() application.ExpenseQueries

	// LedgerFunc mocks the Ledger method.
	LedgerFunc func() application.LedgerQueries

	// TransactionFunc mocks the Transaction method.
	TransactionFunc func(ctx context.Context, f func(tx application.Repositories) error) error

	// UserFunc mocks the User method.
	UserFunc func() application.UserQueries

	// calls tracks calls to the methods.
	calls struct {
		// Expense holds details about calls to the Expense method.
		Expense []struct {
		}
		// Ledger holds details about calls to the Ledger method.
		Ledger []struct {
		}
		// Transaction holds details about calls to the Transaction method.
		Transaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// F is the f argument value.
			F func(tx application.Repositories) error
		}
		// User holds details about calls to the User method.
		User []struct {
		}
	}
	lockExpense     sync.RWMutex
	lockLedger      sync.RWMutex
	lockTransaction sync.RWMutex
	lockUser        sync.RWMutex
}

// Expense calls ExpenseFunc.
func (mock *MockDatabase) Expense() application.ExpenseQueries {
	if mock.ExpenseFunc == nil {
		panic("MockDatabase.ExpenseFunc: method is nil but Database.Expense was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExpense.Lock()
	mock.calls.Expense = append(mock.calls.Expense, callInfo)
	mock.lockExpense.Unlock()
	return mock.ExpenseFunc()
}

// ExpenseCalls gets all the calls that were made to Expense.
// Check the length with:
//
//	len(mockedDatabase.ExpenseCalls())
func (mock *MockDatabase) ExpenseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExpense.RLock()
	calls = mock.calls.Expense
	mock.lockExpense.RUnlock()
	return calls
}

// Ledger calls LedgerFunc.
func (mock *MockDatabase) Ledger() application.LedgerQueries {
	if mock.LedgerFunc == nil {
		panic("MockDatabase.LedgerFunc: method is nil but Database.Ledger was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLedger.Lock()
	mock.calls.Ledger = append(mock.calls.Ledger, callInfo)
	mock.lockLedger.Unlock()
	return mock.LedgerFunc()
}

// LedgerCalls gets all the calls that were made to Ledger.
// Check the length with:
//
//	len(mockedDatabase.LedgerCalls())
func (mock *MockDatabase) LedgerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLedger.RLock()
	calls = mock.calls.Ledger
	mock.lockLedger.RUnlock()
	return calls
}

// Transaction calls TransactionFunc.
func (mock *MockDatabase) Transaction(ctx context.Context, f func(tx application.Repositories) error) error {
	if mock.TransactionFunc == nil {
		panic("MockDatabase.TransactionFunc: method is nil but Database.Transaction was just called")
	}
	callInfo := struct {
		Ctx context.Context
		F   func(tx application.Repositories) error
	}{
		Ctx: ctx,
		F:   f,
	}
	mock.lockTransaction.Lock()
	mock.calls.Transaction = append(mock.calls.Transaction, callInfo)
	mock.lockTransaction.Unlock()
	return mock.TransactionFunc(ctx, f)
}

// TransactionCalls gets all the calls that were made to Transaction.
// Check the length with:
//
//	len(mockedDatabase.TransactionCalls())
func (mock *MockDatabase) TransactionCalls() []struct {
	Ctx context.Context
	F   func(tx application.Repositories) error
} {
	var calls []struct {
		Ctx context.Context
		F   func(tx application.Repositories) error
	}
	mock.lockTransaction.RLock()
	calls = mock.calls.Transaction
	mock.lockTransaction.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *MockDatabase) User() application.UserQueries {
	if mock.UserFunc == nil {
		panic("MockDatabase.UserFunc: method is nil but Database.User was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc()
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedDatabase.UserCalls())
func (mock *MockDatabase) UserCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// Ensure that MockQueries does implement application.Queries.
// If this is not the case, regenerate this file with mockery.
var _ application.Queries = &MockQueries{}

// MockQueries is a mock implementation of application.Queries.
//
//	func TestSomethingThatUsesQueries(t *testing.T) {
//
//		// make and configure a mocked application.Queries
//		mockedQueries := &MockQueries{
//			ExpenseFunc: func() application.ExpenseQueries {
//				panic("mock out the Expense method")
//			},
//			LedgerFunc: func() application.LedgerQueries {
//				panic("mock out the Ledger method")
//			},
//			UserFunc: func() application.UserQueries {
//				panic("mock out the User method")
//			},
//		}
//
//		// use mockedQueries in code that requires application.Queries
//		// and then make assertions.
//
//	}
type MockQueries struct {
	// ExpenseFunc mocks the Expense method.
	ExpenseFunc func() application.ExpenseQueries

	// LedgerFunc mocks the Ledger method.
	LedgerFunc func() application.LedgerQueries

	// UserFunc mocks the User method.
	UserFunc func() application.UserQueries

	// calls tracks calls to the methods.
	calls struct {
		// Expense holds details about calls to the Expense method.
		Expense []struct {
		}
		// Ledger holds details about calls to the Ledger method.
		Ledger []struct {
		}
		// User holds details about calls to the User method.
		User []struct {
		}
	}
	lockExpense sync.RWMutex
	lockLedger  sync.RWMutex
	lockUser    sync.RWMutex
}

// Expense calls ExpenseFunc.
func (mock *MockQueries) Expense() application.ExpenseQueries {
	if mock.ExpenseFunc == nil {
		panic("MockQueries.ExpenseFunc: method is nil but Queries.Expense was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExpense.Lock()
	mock.calls.Expense = append(mock.calls.Expense, callInfo)
	mock.lockExpense.Unlock()
	return mock.ExpenseFunc()
}

// ExpenseCalls gets all the calls that were made to Expense.
// Check the length with:
//
//	len(mockedQueries.ExpenseCalls())
func (mock *MockQueries) ExpenseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExpense.RLock()
	calls = mock.calls.Expense
	mock.lockExpense.RUnlock()
	return calls
}

// Ledger calls LedgerFunc.
func (mock *MockQueries) Ledger() application.LedgerQueries {
	if mock.LedgerFunc == nil {
		panic("MockQueries.LedgerFunc: method is nil but Queries.Ledger was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLedger.Lock()
	mock.calls.Ledger = append(mock.calls.Ledger, callInfo)
	mock.lockLedger.Unlock()
	return mock.LedgerFunc()
}

// LedgerCalls gets all the calls that were made to Ledger.
// Check the length with:
//
//	len(mockedQueries.LedgerCalls())
func (mock *MockQueries) LedgerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLedger.RLock()
	calls = mock.calls.Ledger
	mock.lockLedger.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *MockQueries) User() application.UserQueries {
	if mock.UserFunc == nil {
		panic("MockQueries.UserFunc: method is nil but Queries.User was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc()
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedQueries.UserCalls())
func (mock *MockQueries) UserCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// Ensure that MockRepositories does implement application.Repositories.
// If this is not the case, regenerate this file with mockery.
var _ application.Repositories = &MockRepositories{}

// MockRepositories is a mock implementation of application.Repositories.
//
//	func TestSomethingThatUsesRepositories(t *testing.T) {
//
//		// make and configure a mocked application.Repositories
//		mockedRepositories := &MockRepositories{
//			ExpenseFunc: func() application.ExpenseRepository {
//				panic("mock out the Expense method")
//			},
//			LedgerFunc: func() application.LedgerRepository {
//				panic("mock out the Ledger method")
//			},
//			UserFunc: func() application.UserRepository {
//				panic("mock out the User method")
//			},
//		}
//
//		// use mockedRepositories in code that requires application.Repositories
//		// and then make assertions.
//
//	}
type MockRepositories struct {
	// ExpenseFunc mocks the Expense method.
	ExpenseFunc func() application.ExpenseRepository

	// LedgerFunc mocks the Ledger method.
	LedgerFunc func() application.LedgerRepository

	// UserFunc mocks the User method.
	UserFunc func() application.UserRepository

	// calls tracks calls to the methods.
	calls struct {
		// Expense holds details about calls to the Expense method.
		Expense []struct {
		}
		// Ledger holds details about calls to the Ledger method.
		Ledger []struct {
		}
		// User holds details about calls to the User method.
		User []struct {
		}
	}
	lockExpense sync.RWMutex
	lockLedger  sync.RWMutex
	lockUser    sync.RWMutex
}

// Expense calls ExpenseFunc.
func (mock *MockRepositories) Expense() application.ExpenseRepository {
	if mock.ExpenseFunc == nil {
		panic("MockRepositories.ExpenseFunc: method is nil but Repositories.Expense was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExpense.Lock()
	mock.calls.Expense = append(mock.calls.Expense, callInfo)
	mock.lockExpense.Unlock()
	return mock.ExpenseFunc()
}

// ExpenseCalls gets all the calls that were made to Expense.
// Check the length with:
//
//	len(mockedRepositories.ExpenseCalls())
func (mock *MockRepositories) ExpenseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExpense.RLock()
	calls = mock.calls.Expense
	mock.lockExpense.RUnlock()
	return calls
}

// Ledger calls LedgerFunc.
func (mock *MockRepositories) Ledger() application.LedgerRepository {
	if mock.LedgerFunc == nil {
		panic("MockRepositories.LedgerFunc: method is nil but Repositories.Ledger was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLedger.Lock()
	mock.calls.Ledger = append(mock.calls.Ledger, callInfo)
	mock.lockLedger.Unlock()
	return mock.LedgerFunc()
}

// LedgerCalls gets all the calls that were made to Ledger.
// Check the length with:
//
//	len(mockedRepositories.LedgerCalls())
func (mock *MockRepositories) LedgerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLedger.RLock()
	calls = mock.calls.Ledger
	mock.lockLedger.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *MockRepositories) User() application.UserRepository {
	if mock.UserFunc == nil {
		panic("MockRepositories.UserFunc: method is nil but Repositories.User was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc()
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedRepositories.UserCalls())
func (mock *MockRepositories) UserCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}
