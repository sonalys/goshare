// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package applicationmock

import (
	"context"
	"sync"
	"time"

	"github.com/sonalys/goshare/internal/application"
	"github.com/sonalys/goshare/internal/application/pkg/v1"
	"github.com/sonalys/goshare/internal/domain"
)

// Ensure that LedgerQueries does implement application.LedgerQueries.
// If this is not the case, regenerate this file with mockery.
var _ application.LedgerQueries = &LedgerQueries{}

// LedgerQueries is a mock implementation of application.LedgerQueries.
//
//	func TestSomethingThatUsesLedgerQueries(t *testing.T) {
//
//		// make and configure a mocked application.LedgerQueries
//		mockedLedgerQueries := &LedgerQueries{
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
//				panic("mock out the Find method")
//			},
//			GetByUserFunc: func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
//				panic("mock out the GetByUser method")
//			},
//		}
//
//		// use mockedLedgerQueries in code that requires application.LedgerQueries
//		// and then make assertions.
//
//	}
type LedgerQueries struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.Ledger, error)

	// GetByUserFunc mocks the GetByUser method.
	GetByUserFunc func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error)

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// GetByUser holds details about calls to the GetByUser method.
		GetByUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Identity is the identity argument value.
			Identity domain.ID
		}
	}
	lockFind      sync.RWMutex
	lockGetByUser sync.RWMutex
}

// Find calls FindFunc.
func (mock *LedgerQueries) Find(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
	if mock.FindFunc == nil {
		panic("LedgerQueries.FindFunc: method is nil but LedgerQueries.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedLedgerQueries.FindCalls())
func (mock *LedgerQueries) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// GetByUser calls GetByUserFunc.
func (mock *LedgerQueries) GetByUser(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
	if mock.GetByUserFunc == nil {
		panic("LedgerQueries.GetByUserFunc: method is nil but LedgerQueries.GetByUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Identity domain.ID
	}{
		Ctx:      ctx,
		Identity: identity,
	}
	mock.lockGetByUser.Lock()
	mock.calls.GetByUser = append(mock.calls.GetByUser, callInfo)
	mock.lockGetByUser.Unlock()
	return mock.GetByUserFunc(ctx, identity)
}

// GetByUserCalls gets all the calls that were made to GetByUser.
// Check the length with:
//
//	len(mockedLedgerQueries.GetByUserCalls())
func (mock *LedgerQueries) GetByUserCalls() []struct {
	Ctx      context.Context
	Identity domain.ID
} {
	var calls []struct {
		Ctx      context.Context
		Identity domain.ID
	}
	mock.lockGetByUser.RLock()
	calls = mock.calls.GetByUser
	mock.lockGetByUser.RUnlock()
	return calls
}

// Ensure that LedgerCommands does implement application.LedgerCommands.
// If this is not the case, regenerate this file with mockery.
var _ application.LedgerCommands = &LedgerCommands{}

// LedgerCommands is a mock implementation of application.LedgerCommands.
//
//	func TestSomethingThatUsesLedgerCommands(t *testing.T) {
//
//		// make and configure a mocked application.LedgerCommands
//		mockedLedgerCommands := &LedgerCommands{
//			CreateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Create method")
//			},
//			UpdateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedLedgerCommands in code that requires application.LedgerCommands
//		// and then make assertions.
//
//	}
type LedgerCommands struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
	}
	lockCreate sync.RWMutex
	lockUpdate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *LedgerCommands) Create(ctx context.Context, ledger *domain.Ledger) error {
	if mock.CreateFunc == nil {
		panic("LedgerCommands.CreateFunc: method is nil but LedgerCommands.Create was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledger)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedLedgerCommands.CreateCalls())
func (mock *LedgerCommands) CreateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *LedgerCommands) Update(ctx context.Context, ledger *domain.Ledger) error {
	if mock.UpdateFunc == nil {
		panic("LedgerCommands.UpdateFunc: method is nil but LedgerCommands.Update was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, ledger)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedLedgerCommands.UpdateCalls())
func (mock *LedgerCommands) UpdateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that LedgerRepository does implement application.LedgerRepository.
// If this is not the case, regenerate this file with mockery.
var _ application.LedgerRepository = &LedgerRepository{}

// LedgerRepository is a mock implementation of application.LedgerRepository.
//
//	func TestSomethingThatUsesLedgerRepository(t *testing.T) {
//
//		// make and configure a mocked application.LedgerRepository
//		mockedLedgerRepository := &LedgerRepository{
//			CreateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Create method")
//			},
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
//				panic("mock out the Find method")
//			},
//			GetByUserFunc: func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
//				panic("mock out the GetByUser method")
//			},
//			UpdateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedLedgerRepository in code that requires application.LedgerRepository
//		// and then make assertions.
//
//	}
type LedgerRepository struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.Ledger, error)

	// GetByUserFunc mocks the GetByUser method.
	GetByUserFunc func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// GetByUser holds details about calls to the GetByUser method.
		GetByUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Identity is the identity argument value.
			Identity domain.ID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
	}
	lockCreate    sync.RWMutex
	lockFind      sync.RWMutex
	lockGetByUser sync.RWMutex
	lockUpdate    sync.RWMutex
}

// Create calls CreateFunc.
func (mock *LedgerRepository) Create(ctx context.Context, ledger *domain.Ledger) error {
	if mock.CreateFunc == nil {
		panic("LedgerRepository.CreateFunc: method is nil but LedgerRepository.Create was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledger)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedLedgerRepository.CreateCalls())
func (mock *LedgerRepository) CreateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Find calls FindFunc.
func (mock *LedgerRepository) Find(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
	if mock.FindFunc == nil {
		panic("LedgerRepository.FindFunc: method is nil but LedgerRepository.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedLedgerRepository.FindCalls())
func (mock *LedgerRepository) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// GetByUser calls GetByUserFunc.
func (mock *LedgerRepository) GetByUser(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
	if mock.GetByUserFunc == nil {
		panic("LedgerRepository.GetByUserFunc: method is nil but LedgerRepository.GetByUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Identity domain.ID
	}{
		Ctx:      ctx,
		Identity: identity,
	}
	mock.lockGetByUser.Lock()
	mock.calls.GetByUser = append(mock.calls.GetByUser, callInfo)
	mock.lockGetByUser.Unlock()
	return mock.GetByUserFunc(ctx, identity)
}

// GetByUserCalls gets all the calls that were made to GetByUser.
// Check the length with:
//
//	len(mockedLedgerRepository.GetByUserCalls())
func (mock *LedgerRepository) GetByUserCalls() []struct {
	Ctx      context.Context
	Identity domain.ID
} {
	var calls []struct {
		Ctx      context.Context
		Identity domain.ID
	}
	mock.lockGetByUser.RLock()
	calls = mock.calls.GetByUser
	mock.lockGetByUser.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *LedgerRepository) Update(ctx context.Context, ledger *domain.Ledger) error {
	if mock.UpdateFunc == nil {
		panic("LedgerRepository.UpdateFunc: method is nil but LedgerRepository.Update was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, ledger)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedLedgerRepository.UpdateCalls())
func (mock *LedgerRepository) UpdateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that UserQueries does implement application.UserQueries.
// If this is not the case, regenerate this file with mockery.
var _ application.UserQueries = &UserQueries{}

// UserQueries is a mock implementation of application.UserQueries.
//
//	func TestSomethingThatUsesUserQueries(t *testing.T) {
//
//		// make and configure a mocked application.UserQueries
//		mockedUserQueries := &UserQueries{
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.User, error) {
//				panic("mock out the Find method")
//			},
//			FindByEmailFunc: func(ctx context.Context, email string) (*domain.User, error) {
//				panic("mock out the FindByEmail method")
//			},
//			ListByEmailFunc: func(ctx context.Context, emails []string) ([]domain.User, error) {
//				panic("mock out the ListByEmail method")
//			},
//		}
//
//		// use mockedUserQueries in code that requires application.UserQueries
//		// and then make assertions.
//
//	}
type UserQueries struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.User, error)

	// FindByEmailFunc mocks the FindByEmail method.
	FindByEmailFunc func(ctx context.Context, email string) (*domain.User, error)

	// ListByEmailFunc mocks the ListByEmail method.
	ListByEmailFunc func(ctx context.Context, emails []string) ([]domain.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// FindByEmail holds details about calls to the FindByEmail method.
		FindByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// ListByEmail holds details about calls to the ListByEmail method.
		ListByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Emails is the emails argument value.
			Emails []string
		}
	}
	lockFind        sync.RWMutex
	lockFindByEmail sync.RWMutex
	lockListByEmail sync.RWMutex
}

// Find calls FindFunc.
func (mock *UserQueries) Find(ctx context.Context, id domain.ID) (*domain.User, error) {
	if mock.FindFunc == nil {
		panic("UserQueries.FindFunc: method is nil but UserQueries.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedUserQueries.FindCalls())
func (mock *UserQueries) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// FindByEmail calls FindByEmailFunc.
func (mock *UserQueries) FindByEmail(ctx context.Context, email string) (*domain.User, error) {
	if mock.FindByEmailFunc == nil {
		panic("UserQueries.FindByEmailFunc: method is nil but UserQueries.FindByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockFindByEmail.Lock()
	mock.calls.FindByEmail = append(mock.calls.FindByEmail, callInfo)
	mock.lockFindByEmail.Unlock()
	return mock.FindByEmailFunc(ctx, email)
}

// FindByEmailCalls gets all the calls that were made to FindByEmail.
// Check the length with:
//
//	len(mockedUserQueries.FindByEmailCalls())
func (mock *UserQueries) FindByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockFindByEmail.RLock()
	calls = mock.calls.FindByEmail
	mock.lockFindByEmail.RUnlock()
	return calls
}

// ListByEmail calls ListByEmailFunc.
func (mock *UserQueries) ListByEmail(ctx context.Context, emails []string) ([]domain.User, error) {
	if mock.ListByEmailFunc == nil {
		panic("UserQueries.ListByEmailFunc: method is nil but UserQueries.ListByEmail was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Emails []string
	}{
		Ctx:    ctx,
		Emails: emails,
	}
	mock.lockListByEmail.Lock()
	mock.calls.ListByEmail = append(mock.calls.ListByEmail, callInfo)
	mock.lockListByEmail.Unlock()
	return mock.ListByEmailFunc(ctx, emails)
}

// ListByEmailCalls gets all the calls that were made to ListByEmail.
// Check the length with:
//
//	len(mockedUserQueries.ListByEmailCalls())
func (mock *UserQueries) ListByEmailCalls() []struct {
	Ctx    context.Context
	Emails []string
} {
	var calls []struct {
		Ctx    context.Context
		Emails []string
	}
	mock.lockListByEmail.RLock()
	calls = mock.calls.ListByEmail
	mock.lockListByEmail.RUnlock()
	return calls
}

// Ensure that UserCommands does implement application.UserCommands.
// If this is not the case, regenerate this file with mockery.
var _ application.UserCommands = &UserCommands{}

// UserCommands is a mock implementation of application.UserCommands.
//
//	func TestSomethingThatUsesUserCommands(t *testing.T) {
//
//		// make and configure a mocked application.UserCommands
//		mockedUserCommands := &UserCommands{
//			SaveFunc: func(ctx context.Context, user *domain.User) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedUserCommands in code that requires application.UserCommands
//		// and then make assertions.
//
//	}
type UserCommands struct {
	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, user *domain.User) error

	// calls tracks calls to the methods.
	calls struct {
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User *domain.User
		}
	}
	lockSave sync.RWMutex
}

// Save calls SaveFunc.
func (mock *UserCommands) Save(ctx context.Context, user *domain.User) error {
	if mock.SaveFunc == nil {
		panic("UserCommands.SaveFunc: method is nil but UserCommands.Save was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User *domain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, user)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedUserCommands.SaveCalls())
func (mock *UserCommands) SaveCalls() []struct {
	Ctx  context.Context
	User *domain.User
} {
	var calls []struct {
		Ctx  context.Context
		User *domain.User
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure that UserRepository does implement application.UserRepository.
// If this is not the case, regenerate this file with mockery.
var _ application.UserRepository = &UserRepository{}

// UserRepository is a mock implementation of application.UserRepository.
//
//	func TestSomethingThatUsesUserRepository(t *testing.T) {
//
//		// make and configure a mocked application.UserRepository
//		mockedUserRepository := &UserRepository{
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.User, error) {
//				panic("mock out the Find method")
//			},
//			FindByEmailFunc: func(ctx context.Context, email string) (*domain.User, error) {
//				panic("mock out the FindByEmail method")
//			},
//			ListByEmailFunc: func(ctx context.Context, emails []string) ([]domain.User, error) {
//				panic("mock out the ListByEmail method")
//			},
//			SaveFunc: func(ctx context.Context, user *domain.User) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedUserRepository in code that requires application.UserRepository
//		// and then make assertions.
//
//	}
type UserRepository struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.User, error)

	// FindByEmailFunc mocks the FindByEmail method.
	FindByEmailFunc func(ctx context.Context, email string) (*domain.User, error)

	// ListByEmailFunc mocks the ListByEmail method.
	ListByEmailFunc func(ctx context.Context, emails []string) ([]domain.User, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, user *domain.User) error

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// FindByEmail holds details about calls to the FindByEmail method.
		FindByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// ListByEmail holds details about calls to the ListByEmail method.
		ListByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Emails is the emails argument value.
			Emails []string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User *domain.User
		}
	}
	lockFind        sync.RWMutex
	lockFindByEmail sync.RWMutex
	lockListByEmail sync.RWMutex
	lockSave        sync.RWMutex
}

// Find calls FindFunc.
func (mock *UserRepository) Find(ctx context.Context, id domain.ID) (*domain.User, error) {
	if mock.FindFunc == nil {
		panic("UserRepository.FindFunc: method is nil but UserRepository.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedUserRepository.FindCalls())
func (mock *UserRepository) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// FindByEmail calls FindByEmailFunc.
func (mock *UserRepository) FindByEmail(ctx context.Context, email string) (*domain.User, error) {
	if mock.FindByEmailFunc == nil {
		panic("UserRepository.FindByEmailFunc: method is nil but UserRepository.FindByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockFindByEmail.Lock()
	mock.calls.FindByEmail = append(mock.calls.FindByEmail, callInfo)
	mock.lockFindByEmail.Unlock()
	return mock.FindByEmailFunc(ctx, email)
}

// FindByEmailCalls gets all the calls that were made to FindByEmail.
// Check the length with:
//
//	len(mockedUserRepository.FindByEmailCalls())
func (mock *UserRepository) FindByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockFindByEmail.RLock()
	calls = mock.calls.FindByEmail
	mock.lockFindByEmail.RUnlock()
	return calls
}

// ListByEmail calls ListByEmailFunc.
func (mock *UserRepository) ListByEmail(ctx context.Context, emails []string) ([]domain.User, error) {
	if mock.ListByEmailFunc == nil {
		panic("UserRepository.ListByEmailFunc: method is nil but UserRepository.ListByEmail was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Emails []string
	}{
		Ctx:    ctx,
		Emails: emails,
	}
	mock.lockListByEmail.Lock()
	mock.calls.ListByEmail = append(mock.calls.ListByEmail, callInfo)
	mock.lockListByEmail.Unlock()
	return mock.ListByEmailFunc(ctx, emails)
}

// ListByEmailCalls gets all the calls that were made to ListByEmail.
// Check the length with:
//
//	len(mockedUserRepository.ListByEmailCalls())
func (mock *UserRepository) ListByEmailCalls() []struct {
	Ctx    context.Context
	Emails []string
} {
	var calls []struct {
		Ctx    context.Context
		Emails []string
	}
	mock.lockListByEmail.RLock()
	calls = mock.calls.ListByEmail
	mock.lockListByEmail.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *UserRepository) Save(ctx context.Context, user *domain.User) error {
	if mock.SaveFunc == nil {
		panic("UserRepository.SaveFunc: method is nil but UserRepository.Save was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User *domain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, user)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedUserRepository.SaveCalls())
func (mock *UserRepository) SaveCalls() []struct {
	Ctx  context.Context
	User *domain.User
} {
	var calls []struct {
		Ctx  context.Context
		User *domain.User
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure that ExpenseQueries does implement application.ExpenseQueries.
// If this is not the case, regenerate this file with mockery.
var _ application.ExpenseQueries = &ExpenseQueries{}

// ExpenseQueries is a mock implementation of application.ExpenseQueries.
//
//	func TestSomethingThatUsesExpenseQueries(t *testing.T) {
//
//		// make and configure a mocked application.ExpenseQueries
//		mockedExpenseQueries := &ExpenseQueries{
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.Expense, error) {
//				panic("mock out the Find method")
//			},
//			GetByLedgerFunc: func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
//				panic("mock out the GetByLedger method")
//			},
//		}
//
//		// use mockedExpenseQueries in code that requires application.ExpenseQueries
//		// and then make assertions.
//
//	}
type ExpenseQueries struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.Expense, error)

	// GetByLedgerFunc mocks the GetByLedger method.
	GetByLedgerFunc func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error)

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// GetByLedger holds details about calls to the GetByLedger method.
		GetByLedger []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Cursor is the cursor argument value.
			Cursor time.Time
			// Limit is the limit argument value.
			Limit int32
		}
	}
	lockFind        sync.RWMutex
	lockGetByLedger sync.RWMutex
}

// Find calls FindFunc.
func (mock *ExpenseQueries) Find(ctx context.Context, id domain.ID) (*domain.Expense, error) {
	if mock.FindFunc == nil {
		panic("ExpenseQueries.FindFunc: method is nil but ExpenseQueries.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedExpenseQueries.FindCalls())
func (mock *ExpenseQueries) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// GetByLedger calls GetByLedgerFunc.
func (mock *ExpenseQueries) GetByLedger(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
	if mock.GetByLedgerFunc == nil {
		panic("ExpenseQueries.GetByLedgerFunc: method is nil but ExpenseQueries.GetByLedger was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Cursor:   cursor,
		Limit:    limit,
	}
	mock.lockGetByLedger.Lock()
	mock.calls.GetByLedger = append(mock.calls.GetByLedger, callInfo)
	mock.lockGetByLedger.Unlock()
	return mock.GetByLedgerFunc(ctx, ledgerID, cursor, limit)
}

// GetByLedgerCalls gets all the calls that were made to GetByLedger.
// Check the length with:
//
//	len(mockedExpenseQueries.GetByLedgerCalls())
func (mock *ExpenseQueries) GetByLedgerCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Cursor   time.Time
	Limit    int32
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}
	mock.lockGetByLedger.RLock()
	calls = mock.calls.GetByLedger
	mock.lockGetByLedger.RUnlock()
	return calls
}

// Ensure that ExpenseCommands does implement application.ExpenseCommands.
// If this is not the case, regenerate this file with mockery.
var _ application.ExpenseCommands = &ExpenseCommands{}

// ExpenseCommands is a mock implementation of application.ExpenseCommands.
//
//	func TestSomethingThatUsesExpenseCommands(t *testing.T) {
//
//		// make and configure a mocked application.ExpenseCommands
//		mockedExpenseCommands := &ExpenseCommands{
//			CreateFunc: func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
//				panic("mock out the Create method")
//			},
//			UpdateFunc: func(ctx context.Context, expense *domain.Expense) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedExpenseCommands in code that requires application.ExpenseCommands
//		// and then make assertions.
//
//	}
type ExpenseCommands struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, expense *domain.Expense) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
	}
	lockCreate sync.RWMutex
	lockUpdate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *ExpenseCommands) Create(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
	if mock.CreateFunc == nil {
		panic("ExpenseCommands.CreateFunc: method is nil but ExpenseCommands.Create was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Expense:  expense,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledgerID, expense)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedExpenseCommands.CreateCalls())
func (mock *ExpenseCommands) CreateCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Expense  *domain.Expense
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ExpenseCommands) Update(ctx context.Context, expense *domain.Expense) error {
	if mock.UpdateFunc == nil {
		panic("ExpenseCommands.UpdateFunc: method is nil but ExpenseCommands.Update was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Expense *domain.Expense
	}{
		Ctx:     ctx,
		Expense: expense,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, expense)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedExpenseCommands.UpdateCalls())
func (mock *ExpenseCommands) UpdateCalls() []struct {
	Ctx     context.Context
	Expense *domain.Expense
} {
	var calls []struct {
		Ctx     context.Context
		Expense *domain.Expense
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that ExpenseRepository does implement application.ExpenseRepository.
// If this is not the case, regenerate this file with mockery.
var _ application.ExpenseRepository = &ExpenseRepository{}

// ExpenseRepository is a mock implementation of application.ExpenseRepository.
//
//	func TestSomethingThatUsesExpenseRepository(t *testing.T) {
//
//		// make and configure a mocked application.ExpenseRepository
//		mockedExpenseRepository := &ExpenseRepository{
//			CreateFunc: func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
//				panic("mock out the Create method")
//			},
//			FindFunc: func(ctx context.Context, id domain.ID) (*domain.Expense, error) {
//				panic("mock out the Find method")
//			},
//			GetByLedgerFunc: func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
//				panic("mock out the GetByLedger method")
//			},
//			UpdateFunc: func(ctx context.Context, expense *domain.Expense) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedExpenseRepository in code that requires application.ExpenseRepository
//		// and then make assertions.
//
//	}
type ExpenseRepository struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error

	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id domain.ID) (*domain.Expense, error)

	// GetByLedgerFunc mocks the GetByLedger method.
	GetByLedgerFunc func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, expense *domain.Expense) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// GetByLedger holds details about calls to the GetByLedger method.
		GetByLedger []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Cursor is the cursor argument value.
			Cursor time.Time
			// Limit is the limit argument value.
			Limit int32
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
	}
	lockCreate      sync.RWMutex
	lockFind        sync.RWMutex
	lockGetByLedger sync.RWMutex
	lockUpdate      sync.RWMutex
}

// Create calls CreateFunc.
func (mock *ExpenseRepository) Create(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
	if mock.CreateFunc == nil {
		panic("ExpenseRepository.CreateFunc: method is nil but ExpenseRepository.Create was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Expense:  expense,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledgerID, expense)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedExpenseRepository.CreateCalls())
func (mock *ExpenseRepository) CreateCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Expense  *domain.Expense
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Find calls FindFunc.
func (mock *ExpenseRepository) Find(ctx context.Context, id domain.ID) (*domain.Expense, error) {
	if mock.FindFunc == nil {
		panic("ExpenseRepository.FindFunc: method is nil but ExpenseRepository.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedExpenseRepository.FindCalls())
func (mock *ExpenseRepository) FindCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// GetByLedger calls GetByLedgerFunc.
func (mock *ExpenseRepository) GetByLedger(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
	if mock.GetByLedgerFunc == nil {
		panic("ExpenseRepository.GetByLedgerFunc: method is nil but ExpenseRepository.GetByLedger was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Cursor:   cursor,
		Limit:    limit,
	}
	mock.lockGetByLedger.Lock()
	mock.calls.GetByLedger = append(mock.calls.GetByLedger, callInfo)
	mock.lockGetByLedger.Unlock()
	return mock.GetByLedgerFunc(ctx, ledgerID, cursor, limit)
}

// GetByLedgerCalls gets all the calls that were made to GetByLedger.
// Check the length with:
//
//	len(mockedExpenseRepository.GetByLedgerCalls())
func (mock *ExpenseRepository) GetByLedgerCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Cursor   time.Time
	Limit    int32
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}
	mock.lockGetByLedger.RLock()
	calls = mock.calls.GetByLedger
	mock.lockGetByLedger.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ExpenseRepository) Update(ctx context.Context, expense *domain.Expense) error {
	if mock.UpdateFunc == nil {
		panic("ExpenseRepository.UpdateFunc: method is nil but ExpenseRepository.Update was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Expense *domain.Expense
	}{
		Ctx:     ctx,
		Expense: expense,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, expense)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedExpenseRepository.UpdateCalls())
func (mock *ExpenseRepository) UpdateCalls() []struct {
	Ctx     context.Context
	Expense *domain.Expense
} {
	var calls []struct {
		Ctx     context.Context
		Expense *domain.Expense
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that Database does implement application.Database.
// If this is not the case, regenerate this file with mockery.
var _ application.Database = &Database{}

// Database is a mock implementation of application.Database.
//
//	func TestSomethingThatUsesDatabase(t *testing.T) {
//
//		// make and configure a mocked application.Database
//		mockedDatabase := &Database{
//			ExpenseFunc: func() application.ExpenseQueries {
//				panic("mock out the Expense method")
//			},
//			LedgerFunc: func() application.LedgerQueries {
//				panic("mock out the Ledger method")
//			},
//			TransactionFunc: func(ctx context.Context, f func(tx application.Repositories) error) error {
//				panic("mock out the Transaction method")
//			},
//			UserFunc: func() application.UserQueries {
//				panic("mock out the User method")
//			},
//		}
//
//		// use mockedDatabase in code that requires application.Database
//		// and then make assertions.
//
//	}
type Database struct {
	// ExpenseFunc mocks the Expense method.
	ExpenseFunc func() application.ExpenseQueries

	// LedgerFunc mocks the Ledger method.
	LedgerFunc func() application.LedgerQueries

	// TransactionFunc mocks the Transaction method.
	TransactionFunc func(ctx context.Context, f func(tx application.Repositories) error) error

	// UserFunc mocks the User method.
	UserFunc func() application.UserQueries

	// calls tracks calls to the methods.
	calls struct {
		// Expense holds details about calls to the Expense method.
		Expense []struct {
		}
		// Ledger holds details about calls to the Ledger method.
		Ledger []struct {
		}
		// Transaction holds details about calls to the Transaction method.
		Transaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// F is the f argument value.
			F func(tx application.Repositories) error
		}
		// User holds details about calls to the User method.
		User []struct {
		}
	}
	lockExpense     sync.RWMutex
	lockLedger      sync.RWMutex
	lockTransaction sync.RWMutex
	lockUser        sync.RWMutex
}

// Expense calls ExpenseFunc.
func (mock *Database) Expense() application.ExpenseQueries {
	if mock.ExpenseFunc == nil {
		panic("Database.ExpenseFunc: method is nil but Database.Expense was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExpense.Lock()
	mock.calls.Expense = append(mock.calls.Expense, callInfo)
	mock.lockExpense.Unlock()
	return mock.ExpenseFunc()
}

// ExpenseCalls gets all the calls that were made to Expense.
// Check the length with:
//
//	len(mockedDatabase.ExpenseCalls())
func (mock *Database) ExpenseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExpense.RLock()
	calls = mock.calls.Expense
	mock.lockExpense.RUnlock()
	return calls
}

// Ledger calls LedgerFunc.
func (mock *Database) Ledger() application.LedgerQueries {
	if mock.LedgerFunc == nil {
		panic("Database.LedgerFunc: method is nil but Database.Ledger was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLedger.Lock()
	mock.calls.Ledger = append(mock.calls.Ledger, callInfo)
	mock.lockLedger.Unlock()
	return mock.LedgerFunc()
}

// LedgerCalls gets all the calls that were made to Ledger.
// Check the length with:
//
//	len(mockedDatabase.LedgerCalls())
func (mock *Database) LedgerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLedger.RLock()
	calls = mock.calls.Ledger
	mock.lockLedger.RUnlock()
	return calls
}

// Transaction calls TransactionFunc.
func (mock *Database) Transaction(ctx context.Context, f func(tx application.Repositories) error) error {
	if mock.TransactionFunc == nil {
		panic("Database.TransactionFunc: method is nil but Database.Transaction was just called")
	}
	callInfo := struct {
		Ctx context.Context
		F   func(tx application.Repositories) error
	}{
		Ctx: ctx,
		F:   f,
	}
	mock.lockTransaction.Lock()
	mock.calls.Transaction = append(mock.calls.Transaction, callInfo)
	mock.lockTransaction.Unlock()
	return mock.TransactionFunc(ctx, f)
}

// TransactionCalls gets all the calls that were made to Transaction.
// Check the length with:
//
//	len(mockedDatabase.TransactionCalls())
func (mock *Database) TransactionCalls() []struct {
	Ctx context.Context
	F   func(tx application.Repositories) error
} {
	var calls []struct {
		Ctx context.Context
		F   func(tx application.Repositories) error
	}
	mock.lockTransaction.RLock()
	calls = mock.calls.Transaction
	mock.lockTransaction.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *Database) User() application.UserQueries {
	if mock.UserFunc == nil {
		panic("Database.UserFunc: method is nil but Database.User was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc()
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedDatabase.UserCalls())
func (mock *Database) UserCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// Ensure that Queries does implement application.Queries.
// If this is not the case, regenerate this file with mockery.
var _ application.Queries = &Queries{}

// Queries is a mock implementation of application.Queries.
//
//	func TestSomethingThatUsesQueries(t *testing.T) {
//
//		// make and configure a mocked application.Queries
//		mockedQueries := &Queries{
//			ExpenseFunc: func() application.ExpenseQueries {
//				panic("mock out the Expense method")
//			},
//			LedgerFunc: func() application.LedgerQueries {
//				panic("mock out the Ledger method")
//			},
//			UserFunc: func() application.UserQueries {
//				panic("mock out the User method")
//			},
//		}
//
//		// use mockedQueries in code that requires application.Queries
//		// and then make assertions.
//
//	}
type Queries struct {
	// ExpenseFunc mocks the Expense method.
	ExpenseFunc func() application.ExpenseQueries

	// LedgerFunc mocks the Ledger method.
	LedgerFunc func() application.LedgerQueries

	// UserFunc mocks the User method.
	UserFunc func() application.UserQueries

	// calls tracks calls to the methods.
	calls struct {
		// Expense holds details about calls to the Expense method.
		Expense []struct {
		}
		// Ledger holds details about calls to the Ledger method.
		Ledger []struct {
		}
		// User holds details about calls to the User method.
		User []struct {
		}
	}
	lockExpense sync.RWMutex
	lockLedger  sync.RWMutex
	lockUser    sync.RWMutex
}

// Expense calls ExpenseFunc.
func (mock *Queries) Expense() application.ExpenseQueries {
	if mock.ExpenseFunc == nil {
		panic("Queries.ExpenseFunc: method is nil but Queries.Expense was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExpense.Lock()
	mock.calls.Expense = append(mock.calls.Expense, callInfo)
	mock.lockExpense.Unlock()
	return mock.ExpenseFunc()
}

// ExpenseCalls gets all the calls that were made to Expense.
// Check the length with:
//
//	len(mockedQueries.ExpenseCalls())
func (mock *Queries) ExpenseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExpense.RLock()
	calls = mock.calls.Expense
	mock.lockExpense.RUnlock()
	return calls
}

// Ledger calls LedgerFunc.
func (mock *Queries) Ledger() application.LedgerQueries {
	if mock.LedgerFunc == nil {
		panic("Queries.LedgerFunc: method is nil but Queries.Ledger was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLedger.Lock()
	mock.calls.Ledger = append(mock.calls.Ledger, callInfo)
	mock.lockLedger.Unlock()
	return mock.LedgerFunc()
}

// LedgerCalls gets all the calls that were made to Ledger.
// Check the length with:
//
//	len(mockedQueries.LedgerCalls())
func (mock *Queries) LedgerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLedger.RLock()
	calls = mock.calls.Ledger
	mock.lockLedger.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *Queries) User() application.UserQueries {
	if mock.UserFunc == nil {
		panic("Queries.UserFunc: method is nil but Queries.User was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc()
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedQueries.UserCalls())
func (mock *Queries) UserCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// Ensure that Repositories does implement application.Repositories.
// If this is not the case, regenerate this file with mockery.
var _ application.Repositories = &Repositories{}

// Repositories is a mock implementation of application.Repositories.
//
//	func TestSomethingThatUsesRepositories(t *testing.T) {
//
//		// make and configure a mocked application.Repositories
//		mockedRepositories := &Repositories{
//			ExpenseFunc: func() application.ExpenseRepository {
//				panic("mock out the Expense method")
//			},
//			LedgerFunc: func() application.LedgerRepository {
//				panic("mock out the Ledger method")
//			},
//			UserFunc: func() application.UserRepository {
//				panic("mock out the User method")
//			},
//		}
//
//		// use mockedRepositories in code that requires application.Repositories
//		// and then make assertions.
//
//	}
type Repositories struct {
	// ExpenseFunc mocks the Expense method.
	ExpenseFunc func() application.ExpenseRepository

	// LedgerFunc mocks the Ledger method.
	LedgerFunc func() application.LedgerRepository

	// UserFunc mocks the User method.
	UserFunc func() application.UserRepository

	// calls tracks calls to the methods.
	calls struct {
		// Expense holds details about calls to the Expense method.
		Expense []struct {
		}
		// Ledger holds details about calls to the Ledger method.
		Ledger []struct {
		}
		// User holds details about calls to the User method.
		User []struct {
		}
	}
	lockExpense sync.RWMutex
	lockLedger  sync.RWMutex
	lockUser    sync.RWMutex
}

// Expense calls ExpenseFunc.
func (mock *Repositories) Expense() application.ExpenseRepository {
	if mock.ExpenseFunc == nil {
		panic("Repositories.ExpenseFunc: method is nil but Repositories.Expense was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExpense.Lock()
	mock.calls.Expense = append(mock.calls.Expense, callInfo)
	mock.lockExpense.Unlock()
	return mock.ExpenseFunc()
}

// ExpenseCalls gets all the calls that were made to Expense.
// Check the length with:
//
//	len(mockedRepositories.ExpenseCalls())
func (mock *Repositories) ExpenseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExpense.RLock()
	calls = mock.calls.Expense
	mock.lockExpense.RUnlock()
	return calls
}

// Ledger calls LedgerFunc.
func (mock *Repositories) Ledger() application.LedgerRepository {
	if mock.LedgerFunc == nil {
		panic("Repositories.LedgerFunc: method is nil but Repositories.Ledger was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLedger.Lock()
	mock.calls.Ledger = append(mock.calls.Ledger, callInfo)
	mock.lockLedger.Unlock()
	return mock.LedgerFunc()
}

// LedgerCalls gets all the calls that were made to Ledger.
// Check the length with:
//
//	len(mockedRepositories.LedgerCalls())
func (mock *Repositories) LedgerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLedger.RLock()
	calls = mock.calls.Ledger
	mock.lockLedger.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *Repositories) User() application.UserRepository {
	if mock.UserFunc == nil {
		panic("Repositories.UserFunc: method is nil but Repositories.User was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc()
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedRepositories.UserCalls())
func (mock *Repositories) UserCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}
