// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package servermock

import (
	"context"
	"sync"

	"github.com/sonalys/goshare/internal/infrastructure/http/server"
)

// Ensure that ServerOption does implement server.ServerOption.
// If this is not the case, regenerate this file with mockery.
var _ server.ServerOption = &ServerOption{}

// ServerOption is a mock implementation of server.ServerOption.
//
//	func TestSomethingThatUsesServerOption(t *testing.T) {
//
//		// make and configure a mocked server.ServerOption
//		mockedServerOption := &ServerOption{
//			applyServerFunc: func(serverConfigMoqParam *server.serverConfig)  {
//				panic("mock out the applyServer method")
//			},
//		}
//
//		// use mockedServerOption in code that requires server.ServerOption
//		// and then make assertions.
//
//	}
type ServerOption struct {
	// applyServerFunc mocks the applyServer method.
	applyServerFunc func(serverConfigMoqParam *server.serverConfig)

	// calls tracks calls to the methods.
	calls struct {
		// applyServer holds details about calls to the applyServer method.
		applyServer []struct {
			// ServerConfigMoqParam is the serverConfigMoqParam argument value.
			ServerConfigMoqParam *server.serverConfig
		}
	}
	lockapplyServer sync.RWMutex
}

// applyServer calls applyServerFunc.
func (mock *ServerOption) applyServer(serverConfigMoqParam *server.serverConfig) {
	if mock.applyServerFunc == nil {
		panic("ServerOption.applyServerFunc: method is nil but ServerOption.applyServer was just called")
	}
	callInfo := struct {
		ServerConfigMoqParam *server.serverConfig
	}{
		ServerConfigMoqParam: serverConfigMoqParam,
	}
	mock.lockapplyServer.Lock()
	mock.calls.applyServer = append(mock.calls.applyServer, callInfo)
	mock.lockapplyServer.Unlock()
	mock.applyServerFunc(serverConfigMoqParam)
}

// applyServerCalls gets all the calls that were made to applyServer.
// Check the length with:
//
//	len(mockedServerOption.applyServerCalls())
func (mock *ServerOption) applyServerCalls() []struct {
	ServerConfigMoqParam *server.serverConfig
} {
	var calls []struct {
		ServerConfigMoqParam *server.serverConfig
	}
	mock.lockapplyServer.RLock()
	calls = mock.calls.applyServer
	mock.lockapplyServer.RUnlock()
	return calls
}

// Ensure that ClientOption does implement server.ClientOption.
// If this is not the case, regenerate this file with mockery.
var _ server.ClientOption = &ClientOption{}

// ClientOption is a mock implementation of server.ClientOption.
//
//	func TestSomethingThatUsesClientOption(t *testing.T) {
//
//		// make and configure a mocked server.ClientOption
//		mockedClientOption := &ClientOption{
//			applyClientFunc: func(clientConfigMoqParam *server.clientConfig)  {
//				panic("mock out the applyClient method")
//			},
//		}
//
//		// use mockedClientOption in code that requires server.ClientOption
//		// and then make assertions.
//
//	}
type ClientOption struct {
	// applyClientFunc mocks the applyClient method.
	applyClientFunc func(clientConfigMoqParam *server.clientConfig)

	// calls tracks calls to the methods.
	calls struct {
		// applyClient holds details about calls to the applyClient method.
		applyClient []struct {
			// ClientConfigMoqParam is the clientConfigMoqParam argument value.
			ClientConfigMoqParam *server.clientConfig
		}
	}
	lockapplyClient sync.RWMutex
}

// applyClient calls applyClientFunc.
func (mock *ClientOption) applyClient(clientConfigMoqParam *server.clientConfig) {
	if mock.applyClientFunc == nil {
		panic("ClientOption.applyClientFunc: method is nil but ClientOption.applyClient was just called")
	}
	callInfo := struct {
		ClientConfigMoqParam *server.clientConfig
	}{
		ClientConfigMoqParam: clientConfigMoqParam,
	}
	mock.lockapplyClient.Lock()
	mock.calls.applyClient = append(mock.calls.applyClient, callInfo)
	mock.lockapplyClient.Unlock()
	mock.applyClientFunc(clientConfigMoqParam)
}

// applyClientCalls gets all the calls that were made to applyClient.
// Check the length with:
//
//	len(mockedClientOption.applyClientCalls())
func (mock *ClientOption) applyClientCalls() []struct {
	ClientConfigMoqParam *server.clientConfig
} {
	var calls []struct {
		ClientConfigMoqParam *server.clientConfig
	}
	mock.lockapplyClient.RLock()
	calls = mock.calls.applyClient
	mock.lockapplyClient.RUnlock()
	return calls
}

// Ensure that Option does implement server.Option.
// If this is not the case, regenerate this file with mockery.
var _ server.Option = &Option{}

// Option is a mock implementation of server.Option.
//
//	func TestSomethingThatUsesOption(t *testing.T) {
//
//		// make and configure a mocked server.Option
//		mockedOption := &Option{
//			applyClientFunc: func(clientConfigMoqParam *server.clientConfig)  {
//				panic("mock out the applyClient method")
//			},
//			applyServerFunc: func(serverConfigMoqParam *server.serverConfig)  {
//				panic("mock out the applyServer method")
//			},
//		}
//
//		// use mockedOption in code that requires server.Option
//		// and then make assertions.
//
//	}
type Option struct {
	// applyClientFunc mocks the applyClient method.
	applyClientFunc func(clientConfigMoqParam *server.clientConfig)

	// applyServerFunc mocks the applyServer method.
	applyServerFunc func(serverConfigMoqParam *server.serverConfig)

	// calls tracks calls to the methods.
	calls struct {
		// applyClient holds details about calls to the applyClient method.
		applyClient []struct {
			// ClientConfigMoqParam is the clientConfigMoqParam argument value.
			ClientConfigMoqParam *server.clientConfig
		}
		// applyServer holds details about calls to the applyServer method.
		applyServer []struct {
			// ServerConfigMoqParam is the serverConfigMoqParam argument value.
			ServerConfigMoqParam *server.serverConfig
		}
	}
	lockapplyClient sync.RWMutex
	lockapplyServer sync.RWMutex
}

// applyClient calls applyClientFunc.
func (mock *Option) applyClient(clientConfigMoqParam *server.clientConfig) {
	if mock.applyClientFunc == nil {
		panic("Option.applyClientFunc: method is nil but Option.applyClient was just called")
	}
	callInfo := struct {
		ClientConfigMoqParam *server.clientConfig
	}{
		ClientConfigMoqParam: clientConfigMoqParam,
	}
	mock.lockapplyClient.Lock()
	mock.calls.applyClient = append(mock.calls.applyClient, callInfo)
	mock.lockapplyClient.Unlock()
	mock.applyClientFunc(clientConfigMoqParam)
}

// applyClientCalls gets all the calls that were made to applyClient.
// Check the length with:
//
//	len(mockedOption.applyClientCalls())
func (mock *Option) applyClientCalls() []struct {
	ClientConfigMoqParam *server.clientConfig
} {
	var calls []struct {
		ClientConfigMoqParam *server.clientConfig
	}
	mock.lockapplyClient.RLock()
	calls = mock.calls.applyClient
	mock.lockapplyClient.RUnlock()
	return calls
}

// applyServer calls applyServerFunc.
func (mock *Option) applyServer(serverConfigMoqParam *server.serverConfig) {
	if mock.applyServerFunc == nil {
		panic("Option.applyServerFunc: method is nil but Option.applyServer was just called")
	}
	callInfo := struct {
		ServerConfigMoqParam *server.serverConfig
	}{
		ServerConfigMoqParam: serverConfigMoqParam,
	}
	mock.lockapplyServer.Lock()
	mock.calls.applyServer = append(mock.calls.applyServer, callInfo)
	mock.lockapplyServer.Unlock()
	mock.applyServerFunc(serverConfigMoqParam)
}

// applyServerCalls gets all the calls that were made to applyServer.
// Check the length with:
//
//	len(mockedOption.applyServerCalls())
func (mock *Option) applyServerCalls() []struct {
	ServerConfigMoqParam *server.serverConfig
} {
	var calls []struct {
		ServerConfigMoqParam *server.serverConfig
	}
	mock.lockapplyServer.RLock()
	calls = mock.calls.applyServer
	mock.lockapplyServer.RUnlock()
	return calls
}

// Ensure that Invoker does implement server.Invoker.
// If this is not the case, regenerate this file with mockery.
var _ server.Invoker = &Invoker{}

// Invoker is a mock implementation of server.Invoker.
//
//	func TestSomethingThatUsesInvoker(t *testing.T) {
//
//		// make and configure a mocked server.Invoker
//		mockedInvoker := &Invoker{
//			AuthenticationLoginFunc: func(ctx context.Context, request *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error) {
//				panic("mock out the AuthenticationLogin method")
//			},
//			AuthenticationWhoAmIFunc: func(ctx context.Context) (*server.AuthenticationWhoAmIOK, error) {
//				panic("mock out the AuthenticationWhoAmI method")
//			},
//			HealthcheckFunc: func(ctx context.Context) error {
//				panic("mock out the Healthcheck method")
//			},
//			LedgerCreateFunc: func(ctx context.Context, request *server.LedgerCreateReq) (*server.LedgerCreateOK, error) {
//				panic("mock out the LedgerCreate method")
//			},
//			LedgerExpenseCreateFunc: func(ctx context.Context, request *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error) {
//				panic("mock out the LedgerExpenseCreate method")
//			},
//			LedgerExpenseGetFunc: func(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error) {
//				panic("mock out the LedgerExpenseGet method")
//			},
//			LedgerExpenseListFunc: func(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error) {
//				panic("mock out the LedgerExpenseList method")
//			},
//			LedgerExpenseRecordCreateFunc: func(ctx context.Context, request *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error) {
//				panic("mock out the LedgerExpenseRecordCreate method")
//			},
//			LedgerExpenseRecordDeleteFunc: func(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error {
//				panic("mock out the LedgerExpenseRecordDelete method")
//			},
//			LedgerListFunc: func(ctx context.Context) (*server.LedgerListOK, error) {
//				panic("mock out the LedgerList method")
//			},
//			LedgerMemberAddFunc: func(ctx context.Context, request *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error {
//				panic("mock out the LedgerMemberAdd method")
//			},
//			LedgerMemberListFunc: func(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error) {
//				panic("mock out the LedgerMemberList method")
//			},
//			UserRegisterFunc: func(ctx context.Context, request *server.UserRegisterReq) (*server.UserRegisterOK, error) {
//				panic("mock out the UserRegister method")
//			},
//		}
//
//		// use mockedInvoker in code that requires server.Invoker
//		// and then make assertions.
//
//	}
type Invoker struct {
	// AuthenticationLoginFunc mocks the AuthenticationLogin method.
	AuthenticationLoginFunc func(ctx context.Context, request *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error)

	// AuthenticationWhoAmIFunc mocks the AuthenticationWhoAmI method.
	AuthenticationWhoAmIFunc func(ctx context.Context) (*server.AuthenticationWhoAmIOK, error)

	// HealthcheckFunc mocks the Healthcheck method.
	HealthcheckFunc func(ctx context.Context) error

	// LedgerCreateFunc mocks the LedgerCreate method.
	LedgerCreateFunc func(ctx context.Context, request *server.LedgerCreateReq) (*server.LedgerCreateOK, error)

	// LedgerExpenseCreateFunc mocks the LedgerExpenseCreate method.
	LedgerExpenseCreateFunc func(ctx context.Context, request *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error)

	// LedgerExpenseGetFunc mocks the LedgerExpenseGet method.
	LedgerExpenseGetFunc func(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error)

	// LedgerExpenseListFunc mocks the LedgerExpenseList method.
	LedgerExpenseListFunc func(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error)

	// LedgerExpenseRecordCreateFunc mocks the LedgerExpenseRecordCreate method.
	LedgerExpenseRecordCreateFunc func(ctx context.Context, request *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error)

	// LedgerExpenseRecordDeleteFunc mocks the LedgerExpenseRecordDelete method.
	LedgerExpenseRecordDeleteFunc func(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error

	// LedgerListFunc mocks the LedgerList method.
	LedgerListFunc func(ctx context.Context) (*server.LedgerListOK, error)

	// LedgerMemberAddFunc mocks the LedgerMemberAdd method.
	LedgerMemberAddFunc func(ctx context.Context, request *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error

	// LedgerMemberListFunc mocks the LedgerMemberList method.
	LedgerMemberListFunc func(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error)

	// UserRegisterFunc mocks the UserRegister method.
	UserRegisterFunc func(ctx context.Context, request *server.UserRegisterReq) (*server.UserRegisterOK, error)

	// calls tracks calls to the methods.
	calls struct {
		// AuthenticationLogin holds details about calls to the AuthenticationLogin method.
		AuthenticationLogin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.AuthenticationLoginReq
		}
		// AuthenticationWhoAmI holds details about calls to the AuthenticationWhoAmI method.
		AuthenticationWhoAmI []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Healthcheck holds details about calls to the Healthcheck method.
		Healthcheck []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LedgerCreate holds details about calls to the LedgerCreate method.
		LedgerCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.LedgerCreateReq
		}
		// LedgerExpenseCreate holds details about calls to the LedgerExpenseCreate method.
		LedgerExpenseCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.Expense
			// Params is the params argument value.
			Params server.LedgerExpenseCreateParams
		}
		// LedgerExpenseGet holds details about calls to the LedgerExpenseGet method.
		LedgerExpenseGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseGetParams
		}
		// LedgerExpenseList holds details about calls to the LedgerExpenseList method.
		LedgerExpenseList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseListParams
		}
		// LedgerExpenseRecordCreate holds details about calls to the LedgerExpenseRecordCreate method.
		LedgerExpenseRecordCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.LedgerExpenseRecordCreateReq
			// Params is the params argument value.
			Params server.LedgerExpenseRecordCreateParams
		}
		// LedgerExpenseRecordDelete holds details about calls to the LedgerExpenseRecordDelete method.
		LedgerExpenseRecordDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseRecordDeleteParams
		}
		// LedgerList holds details about calls to the LedgerList method.
		LedgerList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LedgerMemberAdd holds details about calls to the LedgerMemberAdd method.
		LedgerMemberAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.LedgerMemberAddReq
			// Params is the params argument value.
			Params server.LedgerMemberAddParams
		}
		// LedgerMemberList holds details about calls to the LedgerMemberList method.
		LedgerMemberList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerMemberListParams
		}
		// UserRegister holds details about calls to the UserRegister method.
		UserRegister []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.UserRegisterReq
		}
	}
	lockAuthenticationLogin       sync.RWMutex
	lockAuthenticationWhoAmI      sync.RWMutex
	lockHealthcheck               sync.RWMutex
	lockLedgerCreate              sync.RWMutex
	lockLedgerExpenseCreate       sync.RWMutex
	lockLedgerExpenseGet          sync.RWMutex
	lockLedgerExpenseList         sync.RWMutex
	lockLedgerExpenseRecordCreate sync.RWMutex
	lockLedgerExpenseRecordDelete sync.RWMutex
	lockLedgerList                sync.RWMutex
	lockLedgerMemberAdd           sync.RWMutex
	lockLedgerMemberList          sync.RWMutex
	lockUserRegister              sync.RWMutex
}

// AuthenticationLogin calls AuthenticationLoginFunc.
func (mock *Invoker) AuthenticationLogin(ctx context.Context, request *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error) {
	if mock.AuthenticationLoginFunc == nil {
		panic("Invoker.AuthenticationLoginFunc: method is nil but Invoker.AuthenticationLogin was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.AuthenticationLoginReq
	}{
		Ctx:     ctx,
		Request: request,
	}
	mock.lockAuthenticationLogin.Lock()
	mock.calls.AuthenticationLogin = append(mock.calls.AuthenticationLogin, callInfo)
	mock.lockAuthenticationLogin.Unlock()
	return mock.AuthenticationLoginFunc(ctx, request)
}

// AuthenticationLoginCalls gets all the calls that were made to AuthenticationLogin.
// Check the length with:
//
//	len(mockedInvoker.AuthenticationLoginCalls())
func (mock *Invoker) AuthenticationLoginCalls() []struct {
	Ctx     context.Context
	Request *server.AuthenticationLoginReq
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.AuthenticationLoginReq
	}
	mock.lockAuthenticationLogin.RLock()
	calls = mock.calls.AuthenticationLogin
	mock.lockAuthenticationLogin.RUnlock()
	return calls
}

// AuthenticationWhoAmI calls AuthenticationWhoAmIFunc.
func (mock *Invoker) AuthenticationWhoAmI(ctx context.Context) (*server.AuthenticationWhoAmIOK, error) {
	if mock.AuthenticationWhoAmIFunc == nil {
		panic("Invoker.AuthenticationWhoAmIFunc: method is nil but Invoker.AuthenticationWhoAmI was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAuthenticationWhoAmI.Lock()
	mock.calls.AuthenticationWhoAmI = append(mock.calls.AuthenticationWhoAmI, callInfo)
	mock.lockAuthenticationWhoAmI.Unlock()
	return mock.AuthenticationWhoAmIFunc(ctx)
}

// AuthenticationWhoAmICalls gets all the calls that were made to AuthenticationWhoAmI.
// Check the length with:
//
//	len(mockedInvoker.AuthenticationWhoAmICalls())
func (mock *Invoker) AuthenticationWhoAmICalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAuthenticationWhoAmI.RLock()
	calls = mock.calls.AuthenticationWhoAmI
	mock.lockAuthenticationWhoAmI.RUnlock()
	return calls
}

// Healthcheck calls HealthcheckFunc.
func (mock *Invoker) Healthcheck(ctx context.Context) error {
	if mock.HealthcheckFunc == nil {
		panic("Invoker.HealthcheckFunc: method is nil but Invoker.Healthcheck was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHealthcheck.Lock()
	mock.calls.Healthcheck = append(mock.calls.Healthcheck, callInfo)
	mock.lockHealthcheck.Unlock()
	return mock.HealthcheckFunc(ctx)
}

// HealthcheckCalls gets all the calls that were made to Healthcheck.
// Check the length with:
//
//	len(mockedInvoker.HealthcheckCalls())
func (mock *Invoker) HealthcheckCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHealthcheck.RLock()
	calls = mock.calls.Healthcheck
	mock.lockHealthcheck.RUnlock()
	return calls
}

// LedgerCreate calls LedgerCreateFunc.
func (mock *Invoker) LedgerCreate(ctx context.Context, request *server.LedgerCreateReq) (*server.LedgerCreateOK, error) {
	if mock.LedgerCreateFunc == nil {
		panic("Invoker.LedgerCreateFunc: method is nil but Invoker.LedgerCreate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.LedgerCreateReq
	}{
		Ctx:     ctx,
		Request: request,
	}
	mock.lockLedgerCreate.Lock()
	mock.calls.LedgerCreate = append(mock.calls.LedgerCreate, callInfo)
	mock.lockLedgerCreate.Unlock()
	return mock.LedgerCreateFunc(ctx, request)
}

// LedgerCreateCalls gets all the calls that were made to LedgerCreate.
// Check the length with:
//
//	len(mockedInvoker.LedgerCreateCalls())
func (mock *Invoker) LedgerCreateCalls() []struct {
	Ctx     context.Context
	Request *server.LedgerCreateReq
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.LedgerCreateReq
	}
	mock.lockLedgerCreate.RLock()
	calls = mock.calls.LedgerCreate
	mock.lockLedgerCreate.RUnlock()
	return calls
}

// LedgerExpenseCreate calls LedgerExpenseCreateFunc.
func (mock *Invoker) LedgerExpenseCreate(ctx context.Context, request *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error) {
	if mock.LedgerExpenseCreateFunc == nil {
		panic("Invoker.LedgerExpenseCreateFunc: method is nil but Invoker.LedgerExpenseCreate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.Expense
		Params  server.LedgerExpenseCreateParams
	}{
		Ctx:     ctx,
		Request: request,
		Params:  params,
	}
	mock.lockLedgerExpenseCreate.Lock()
	mock.calls.LedgerExpenseCreate = append(mock.calls.LedgerExpenseCreate, callInfo)
	mock.lockLedgerExpenseCreate.Unlock()
	return mock.LedgerExpenseCreateFunc(ctx, request, params)
}

// LedgerExpenseCreateCalls gets all the calls that were made to LedgerExpenseCreate.
// Check the length with:
//
//	len(mockedInvoker.LedgerExpenseCreateCalls())
func (mock *Invoker) LedgerExpenseCreateCalls() []struct {
	Ctx     context.Context
	Request *server.Expense
	Params  server.LedgerExpenseCreateParams
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.Expense
		Params  server.LedgerExpenseCreateParams
	}
	mock.lockLedgerExpenseCreate.RLock()
	calls = mock.calls.LedgerExpenseCreate
	mock.lockLedgerExpenseCreate.RUnlock()
	return calls
}

// LedgerExpenseGet calls LedgerExpenseGetFunc.
func (mock *Invoker) LedgerExpenseGet(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error) {
	if mock.LedgerExpenseGetFunc == nil {
		panic("Invoker.LedgerExpenseGetFunc: method is nil but Invoker.LedgerExpenseGet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseGetParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseGet.Lock()
	mock.calls.LedgerExpenseGet = append(mock.calls.LedgerExpenseGet, callInfo)
	mock.lockLedgerExpenseGet.Unlock()
	return mock.LedgerExpenseGetFunc(ctx, params)
}

// LedgerExpenseGetCalls gets all the calls that were made to LedgerExpenseGet.
// Check the length with:
//
//	len(mockedInvoker.LedgerExpenseGetCalls())
func (mock *Invoker) LedgerExpenseGetCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseGetParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseGetParams
	}
	mock.lockLedgerExpenseGet.RLock()
	calls = mock.calls.LedgerExpenseGet
	mock.lockLedgerExpenseGet.RUnlock()
	return calls
}

// LedgerExpenseList calls LedgerExpenseListFunc.
func (mock *Invoker) LedgerExpenseList(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error) {
	if mock.LedgerExpenseListFunc == nil {
		panic("Invoker.LedgerExpenseListFunc: method is nil but Invoker.LedgerExpenseList was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseListParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseList.Lock()
	mock.calls.LedgerExpenseList = append(mock.calls.LedgerExpenseList, callInfo)
	mock.lockLedgerExpenseList.Unlock()
	return mock.LedgerExpenseListFunc(ctx, params)
}

// LedgerExpenseListCalls gets all the calls that were made to LedgerExpenseList.
// Check the length with:
//
//	len(mockedInvoker.LedgerExpenseListCalls())
func (mock *Invoker) LedgerExpenseListCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseListParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseListParams
	}
	mock.lockLedgerExpenseList.RLock()
	calls = mock.calls.LedgerExpenseList
	mock.lockLedgerExpenseList.RUnlock()
	return calls
}

// LedgerExpenseRecordCreate calls LedgerExpenseRecordCreateFunc.
func (mock *Invoker) LedgerExpenseRecordCreate(ctx context.Context, request *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error) {
	if mock.LedgerExpenseRecordCreateFunc == nil {
		panic("Invoker.LedgerExpenseRecordCreateFunc: method is nil but Invoker.LedgerExpenseRecordCreate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.LedgerExpenseRecordCreateReq
		Params  server.LedgerExpenseRecordCreateParams
	}{
		Ctx:     ctx,
		Request: request,
		Params:  params,
	}
	mock.lockLedgerExpenseRecordCreate.Lock()
	mock.calls.LedgerExpenseRecordCreate = append(mock.calls.LedgerExpenseRecordCreate, callInfo)
	mock.lockLedgerExpenseRecordCreate.Unlock()
	return mock.LedgerExpenseRecordCreateFunc(ctx, request, params)
}

// LedgerExpenseRecordCreateCalls gets all the calls that were made to LedgerExpenseRecordCreate.
// Check the length with:
//
//	len(mockedInvoker.LedgerExpenseRecordCreateCalls())
func (mock *Invoker) LedgerExpenseRecordCreateCalls() []struct {
	Ctx     context.Context
	Request *server.LedgerExpenseRecordCreateReq
	Params  server.LedgerExpenseRecordCreateParams
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.LedgerExpenseRecordCreateReq
		Params  server.LedgerExpenseRecordCreateParams
	}
	mock.lockLedgerExpenseRecordCreate.RLock()
	calls = mock.calls.LedgerExpenseRecordCreate
	mock.lockLedgerExpenseRecordCreate.RUnlock()
	return calls
}

// LedgerExpenseRecordDelete calls LedgerExpenseRecordDeleteFunc.
func (mock *Invoker) LedgerExpenseRecordDelete(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error {
	if mock.LedgerExpenseRecordDeleteFunc == nil {
		panic("Invoker.LedgerExpenseRecordDeleteFunc: method is nil but Invoker.LedgerExpenseRecordDelete was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseRecordDeleteParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseRecordDelete.Lock()
	mock.calls.LedgerExpenseRecordDelete = append(mock.calls.LedgerExpenseRecordDelete, callInfo)
	mock.lockLedgerExpenseRecordDelete.Unlock()
	return mock.LedgerExpenseRecordDeleteFunc(ctx, params)
}

// LedgerExpenseRecordDeleteCalls gets all the calls that were made to LedgerExpenseRecordDelete.
// Check the length with:
//
//	len(mockedInvoker.LedgerExpenseRecordDeleteCalls())
func (mock *Invoker) LedgerExpenseRecordDeleteCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseRecordDeleteParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseRecordDeleteParams
	}
	mock.lockLedgerExpenseRecordDelete.RLock()
	calls = mock.calls.LedgerExpenseRecordDelete
	mock.lockLedgerExpenseRecordDelete.RUnlock()
	return calls
}

// LedgerList calls LedgerListFunc.
func (mock *Invoker) LedgerList(ctx context.Context) (*server.LedgerListOK, error) {
	if mock.LedgerListFunc == nil {
		panic("Invoker.LedgerListFunc: method is nil but Invoker.LedgerList was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLedgerList.Lock()
	mock.calls.LedgerList = append(mock.calls.LedgerList, callInfo)
	mock.lockLedgerList.Unlock()
	return mock.LedgerListFunc(ctx)
}

// LedgerListCalls gets all the calls that were made to LedgerList.
// Check the length with:
//
//	len(mockedInvoker.LedgerListCalls())
func (mock *Invoker) LedgerListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLedgerList.RLock()
	calls = mock.calls.LedgerList
	mock.lockLedgerList.RUnlock()
	return calls
}

// LedgerMemberAdd calls LedgerMemberAddFunc.
func (mock *Invoker) LedgerMemberAdd(ctx context.Context, request *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error {
	if mock.LedgerMemberAddFunc == nil {
		panic("Invoker.LedgerMemberAddFunc: method is nil but Invoker.LedgerMemberAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.LedgerMemberAddReq
		Params  server.LedgerMemberAddParams
	}{
		Ctx:     ctx,
		Request: request,
		Params:  params,
	}
	mock.lockLedgerMemberAdd.Lock()
	mock.calls.LedgerMemberAdd = append(mock.calls.LedgerMemberAdd, callInfo)
	mock.lockLedgerMemberAdd.Unlock()
	return mock.LedgerMemberAddFunc(ctx, request, params)
}

// LedgerMemberAddCalls gets all the calls that were made to LedgerMemberAdd.
// Check the length with:
//
//	len(mockedInvoker.LedgerMemberAddCalls())
func (mock *Invoker) LedgerMemberAddCalls() []struct {
	Ctx     context.Context
	Request *server.LedgerMemberAddReq
	Params  server.LedgerMemberAddParams
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.LedgerMemberAddReq
		Params  server.LedgerMemberAddParams
	}
	mock.lockLedgerMemberAdd.RLock()
	calls = mock.calls.LedgerMemberAdd
	mock.lockLedgerMemberAdd.RUnlock()
	return calls
}

// LedgerMemberList calls LedgerMemberListFunc.
func (mock *Invoker) LedgerMemberList(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error) {
	if mock.LedgerMemberListFunc == nil {
		panic("Invoker.LedgerMemberListFunc: method is nil but Invoker.LedgerMemberList was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerMemberListParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerMemberList.Lock()
	mock.calls.LedgerMemberList = append(mock.calls.LedgerMemberList, callInfo)
	mock.lockLedgerMemberList.Unlock()
	return mock.LedgerMemberListFunc(ctx, params)
}

// LedgerMemberListCalls gets all the calls that were made to LedgerMemberList.
// Check the length with:
//
//	len(mockedInvoker.LedgerMemberListCalls())
func (mock *Invoker) LedgerMemberListCalls() []struct {
	Ctx    context.Context
	Params server.LedgerMemberListParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerMemberListParams
	}
	mock.lockLedgerMemberList.RLock()
	calls = mock.calls.LedgerMemberList
	mock.lockLedgerMemberList.RUnlock()
	return calls
}

// UserRegister calls UserRegisterFunc.
func (mock *Invoker) UserRegister(ctx context.Context, request *server.UserRegisterReq) (*server.UserRegisterOK, error) {
	if mock.UserRegisterFunc == nil {
		panic("Invoker.UserRegisterFunc: method is nil but Invoker.UserRegister was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.UserRegisterReq
	}{
		Ctx:     ctx,
		Request: request,
	}
	mock.lockUserRegister.Lock()
	mock.calls.UserRegister = append(mock.calls.UserRegister, callInfo)
	mock.lockUserRegister.Unlock()
	return mock.UserRegisterFunc(ctx, request)
}

// UserRegisterCalls gets all the calls that were made to UserRegister.
// Check the length with:
//
//	len(mockedInvoker.UserRegisterCalls())
func (mock *Invoker) UserRegisterCalls() []struct {
	Ctx     context.Context
	Request *server.UserRegisterReq
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.UserRegisterReq
	}
	mock.lockUserRegister.RLock()
	calls = mock.calls.UserRegister
	mock.lockUserRegister.RUnlock()
	return calls
}

// Ensure that HealthcheckInvoker does implement server.HealthcheckInvoker.
// If this is not the case, regenerate this file with mockery.
var _ server.HealthcheckInvoker = &HealthcheckInvoker{}

// HealthcheckInvoker is a mock implementation of server.HealthcheckInvoker.
//
//	func TestSomethingThatUsesHealthcheckInvoker(t *testing.T) {
//
//		// make and configure a mocked server.HealthcheckInvoker
//		mockedHealthcheckInvoker := &HealthcheckInvoker{
//			HealthcheckFunc: func(ctx context.Context) error {
//				panic("mock out the Healthcheck method")
//			},
//		}
//
//		// use mockedHealthcheckInvoker in code that requires server.HealthcheckInvoker
//		// and then make assertions.
//
//	}
type HealthcheckInvoker struct {
	// HealthcheckFunc mocks the Healthcheck method.
	HealthcheckFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// Healthcheck holds details about calls to the Healthcheck method.
		Healthcheck []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockHealthcheck sync.RWMutex
}

// Healthcheck calls HealthcheckFunc.
func (mock *HealthcheckInvoker) Healthcheck(ctx context.Context) error {
	if mock.HealthcheckFunc == nil {
		panic("HealthcheckInvoker.HealthcheckFunc: method is nil but HealthcheckInvoker.Healthcheck was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHealthcheck.Lock()
	mock.calls.Healthcheck = append(mock.calls.Healthcheck, callInfo)
	mock.lockHealthcheck.Unlock()
	return mock.HealthcheckFunc(ctx)
}

// HealthcheckCalls gets all the calls that were made to Healthcheck.
// Check the length with:
//
//	len(mockedHealthcheckInvoker.HealthcheckCalls())
func (mock *HealthcheckInvoker) HealthcheckCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHealthcheck.RLock()
	calls = mock.calls.Healthcheck
	mock.lockHealthcheck.RUnlock()
	return calls
}

// Ensure that LedgersInvoker does implement server.LedgersInvoker.
// If this is not the case, regenerate this file with mockery.
var _ server.LedgersInvoker = &LedgersInvoker{}

// LedgersInvoker is a mock implementation of server.LedgersInvoker.
//
//	func TestSomethingThatUsesLedgersInvoker(t *testing.T) {
//
//		// make and configure a mocked server.LedgersInvoker
//		mockedLedgersInvoker := &LedgersInvoker{
//			LedgerCreateFunc: func(ctx context.Context, request *server.LedgerCreateReq) (*server.LedgerCreateOK, error) {
//				panic("mock out the LedgerCreate method")
//			},
//			LedgerExpenseCreateFunc: func(ctx context.Context, request *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error) {
//				panic("mock out the LedgerExpenseCreate method")
//			},
//			LedgerExpenseGetFunc: func(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error) {
//				panic("mock out the LedgerExpenseGet method")
//			},
//			LedgerExpenseListFunc: func(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error) {
//				panic("mock out the LedgerExpenseList method")
//			},
//			LedgerExpenseRecordCreateFunc: func(ctx context.Context, request *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error) {
//				panic("mock out the LedgerExpenseRecordCreate method")
//			},
//			LedgerExpenseRecordDeleteFunc: func(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error {
//				panic("mock out the LedgerExpenseRecordDelete method")
//			},
//			LedgerListFunc: func(ctx context.Context) (*server.LedgerListOK, error) {
//				panic("mock out the LedgerList method")
//			},
//			LedgerMemberAddFunc: func(ctx context.Context, request *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error {
//				panic("mock out the LedgerMemberAdd method")
//			},
//			LedgerMemberListFunc: func(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error) {
//				panic("mock out the LedgerMemberList method")
//			},
//		}
//
//		// use mockedLedgersInvoker in code that requires server.LedgersInvoker
//		// and then make assertions.
//
//	}
type LedgersInvoker struct {
	// LedgerCreateFunc mocks the LedgerCreate method.
	LedgerCreateFunc func(ctx context.Context, request *server.LedgerCreateReq) (*server.LedgerCreateOK, error)

	// LedgerExpenseCreateFunc mocks the LedgerExpenseCreate method.
	LedgerExpenseCreateFunc func(ctx context.Context, request *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error)

	// LedgerExpenseGetFunc mocks the LedgerExpenseGet method.
	LedgerExpenseGetFunc func(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error)

	// LedgerExpenseListFunc mocks the LedgerExpenseList method.
	LedgerExpenseListFunc func(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error)

	// LedgerExpenseRecordCreateFunc mocks the LedgerExpenseRecordCreate method.
	LedgerExpenseRecordCreateFunc func(ctx context.Context, request *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error)

	// LedgerExpenseRecordDeleteFunc mocks the LedgerExpenseRecordDelete method.
	LedgerExpenseRecordDeleteFunc func(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error

	// LedgerListFunc mocks the LedgerList method.
	LedgerListFunc func(ctx context.Context) (*server.LedgerListOK, error)

	// LedgerMemberAddFunc mocks the LedgerMemberAdd method.
	LedgerMemberAddFunc func(ctx context.Context, request *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error

	// LedgerMemberListFunc mocks the LedgerMemberList method.
	LedgerMemberListFunc func(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error)

	// calls tracks calls to the methods.
	calls struct {
		// LedgerCreate holds details about calls to the LedgerCreate method.
		LedgerCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.LedgerCreateReq
		}
		// LedgerExpenseCreate holds details about calls to the LedgerExpenseCreate method.
		LedgerExpenseCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.Expense
			// Params is the params argument value.
			Params server.LedgerExpenseCreateParams
		}
		// LedgerExpenseGet holds details about calls to the LedgerExpenseGet method.
		LedgerExpenseGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseGetParams
		}
		// LedgerExpenseList holds details about calls to the LedgerExpenseList method.
		LedgerExpenseList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseListParams
		}
		// LedgerExpenseRecordCreate holds details about calls to the LedgerExpenseRecordCreate method.
		LedgerExpenseRecordCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.LedgerExpenseRecordCreateReq
			// Params is the params argument value.
			Params server.LedgerExpenseRecordCreateParams
		}
		// LedgerExpenseRecordDelete holds details about calls to the LedgerExpenseRecordDelete method.
		LedgerExpenseRecordDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseRecordDeleteParams
		}
		// LedgerList holds details about calls to the LedgerList method.
		LedgerList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LedgerMemberAdd holds details about calls to the LedgerMemberAdd method.
		LedgerMemberAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.LedgerMemberAddReq
			// Params is the params argument value.
			Params server.LedgerMemberAddParams
		}
		// LedgerMemberList holds details about calls to the LedgerMemberList method.
		LedgerMemberList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerMemberListParams
		}
	}
	lockLedgerCreate              sync.RWMutex
	lockLedgerExpenseCreate       sync.RWMutex
	lockLedgerExpenseGet          sync.RWMutex
	lockLedgerExpenseList         sync.RWMutex
	lockLedgerExpenseRecordCreate sync.RWMutex
	lockLedgerExpenseRecordDelete sync.RWMutex
	lockLedgerList                sync.RWMutex
	lockLedgerMemberAdd           sync.RWMutex
	lockLedgerMemberList          sync.RWMutex
}

// LedgerCreate calls LedgerCreateFunc.
func (mock *LedgersInvoker) LedgerCreate(ctx context.Context, request *server.LedgerCreateReq) (*server.LedgerCreateOK, error) {
	if mock.LedgerCreateFunc == nil {
		panic("LedgersInvoker.LedgerCreateFunc: method is nil but LedgersInvoker.LedgerCreate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.LedgerCreateReq
	}{
		Ctx:     ctx,
		Request: request,
	}
	mock.lockLedgerCreate.Lock()
	mock.calls.LedgerCreate = append(mock.calls.LedgerCreate, callInfo)
	mock.lockLedgerCreate.Unlock()
	return mock.LedgerCreateFunc(ctx, request)
}

// LedgerCreateCalls gets all the calls that were made to LedgerCreate.
// Check the length with:
//
//	len(mockedLedgersInvoker.LedgerCreateCalls())
func (mock *LedgersInvoker) LedgerCreateCalls() []struct {
	Ctx     context.Context
	Request *server.LedgerCreateReq
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.LedgerCreateReq
	}
	mock.lockLedgerCreate.RLock()
	calls = mock.calls.LedgerCreate
	mock.lockLedgerCreate.RUnlock()
	return calls
}

// LedgerExpenseCreate calls LedgerExpenseCreateFunc.
func (mock *LedgersInvoker) LedgerExpenseCreate(ctx context.Context, request *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error) {
	if mock.LedgerExpenseCreateFunc == nil {
		panic("LedgersInvoker.LedgerExpenseCreateFunc: method is nil but LedgersInvoker.LedgerExpenseCreate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.Expense
		Params  server.LedgerExpenseCreateParams
	}{
		Ctx:     ctx,
		Request: request,
		Params:  params,
	}
	mock.lockLedgerExpenseCreate.Lock()
	mock.calls.LedgerExpenseCreate = append(mock.calls.LedgerExpenseCreate, callInfo)
	mock.lockLedgerExpenseCreate.Unlock()
	return mock.LedgerExpenseCreateFunc(ctx, request, params)
}

// LedgerExpenseCreateCalls gets all the calls that were made to LedgerExpenseCreate.
// Check the length with:
//
//	len(mockedLedgersInvoker.LedgerExpenseCreateCalls())
func (mock *LedgersInvoker) LedgerExpenseCreateCalls() []struct {
	Ctx     context.Context
	Request *server.Expense
	Params  server.LedgerExpenseCreateParams
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.Expense
		Params  server.LedgerExpenseCreateParams
	}
	mock.lockLedgerExpenseCreate.RLock()
	calls = mock.calls.LedgerExpenseCreate
	mock.lockLedgerExpenseCreate.RUnlock()
	return calls
}

// LedgerExpenseGet calls LedgerExpenseGetFunc.
func (mock *LedgersInvoker) LedgerExpenseGet(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error) {
	if mock.LedgerExpenseGetFunc == nil {
		panic("LedgersInvoker.LedgerExpenseGetFunc: method is nil but LedgersInvoker.LedgerExpenseGet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseGetParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseGet.Lock()
	mock.calls.LedgerExpenseGet = append(mock.calls.LedgerExpenseGet, callInfo)
	mock.lockLedgerExpenseGet.Unlock()
	return mock.LedgerExpenseGetFunc(ctx, params)
}

// LedgerExpenseGetCalls gets all the calls that were made to LedgerExpenseGet.
// Check the length with:
//
//	len(mockedLedgersInvoker.LedgerExpenseGetCalls())
func (mock *LedgersInvoker) LedgerExpenseGetCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseGetParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseGetParams
	}
	mock.lockLedgerExpenseGet.RLock()
	calls = mock.calls.LedgerExpenseGet
	mock.lockLedgerExpenseGet.RUnlock()
	return calls
}

// LedgerExpenseList calls LedgerExpenseListFunc.
func (mock *LedgersInvoker) LedgerExpenseList(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error) {
	if mock.LedgerExpenseListFunc == nil {
		panic("LedgersInvoker.LedgerExpenseListFunc: method is nil but LedgersInvoker.LedgerExpenseList was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseListParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseList.Lock()
	mock.calls.LedgerExpenseList = append(mock.calls.LedgerExpenseList, callInfo)
	mock.lockLedgerExpenseList.Unlock()
	return mock.LedgerExpenseListFunc(ctx, params)
}

// LedgerExpenseListCalls gets all the calls that were made to LedgerExpenseList.
// Check the length with:
//
//	len(mockedLedgersInvoker.LedgerExpenseListCalls())
func (mock *LedgersInvoker) LedgerExpenseListCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseListParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseListParams
	}
	mock.lockLedgerExpenseList.RLock()
	calls = mock.calls.LedgerExpenseList
	mock.lockLedgerExpenseList.RUnlock()
	return calls
}

// LedgerExpenseRecordCreate calls LedgerExpenseRecordCreateFunc.
func (mock *LedgersInvoker) LedgerExpenseRecordCreate(ctx context.Context, request *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error) {
	if mock.LedgerExpenseRecordCreateFunc == nil {
		panic("LedgersInvoker.LedgerExpenseRecordCreateFunc: method is nil but LedgersInvoker.LedgerExpenseRecordCreate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.LedgerExpenseRecordCreateReq
		Params  server.LedgerExpenseRecordCreateParams
	}{
		Ctx:     ctx,
		Request: request,
		Params:  params,
	}
	mock.lockLedgerExpenseRecordCreate.Lock()
	mock.calls.LedgerExpenseRecordCreate = append(mock.calls.LedgerExpenseRecordCreate, callInfo)
	mock.lockLedgerExpenseRecordCreate.Unlock()
	return mock.LedgerExpenseRecordCreateFunc(ctx, request, params)
}

// LedgerExpenseRecordCreateCalls gets all the calls that were made to LedgerExpenseRecordCreate.
// Check the length with:
//
//	len(mockedLedgersInvoker.LedgerExpenseRecordCreateCalls())
func (mock *LedgersInvoker) LedgerExpenseRecordCreateCalls() []struct {
	Ctx     context.Context
	Request *server.LedgerExpenseRecordCreateReq
	Params  server.LedgerExpenseRecordCreateParams
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.LedgerExpenseRecordCreateReq
		Params  server.LedgerExpenseRecordCreateParams
	}
	mock.lockLedgerExpenseRecordCreate.RLock()
	calls = mock.calls.LedgerExpenseRecordCreate
	mock.lockLedgerExpenseRecordCreate.RUnlock()
	return calls
}

// LedgerExpenseRecordDelete calls LedgerExpenseRecordDeleteFunc.
func (mock *LedgersInvoker) LedgerExpenseRecordDelete(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error {
	if mock.LedgerExpenseRecordDeleteFunc == nil {
		panic("LedgersInvoker.LedgerExpenseRecordDeleteFunc: method is nil but LedgersInvoker.LedgerExpenseRecordDelete was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseRecordDeleteParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseRecordDelete.Lock()
	mock.calls.LedgerExpenseRecordDelete = append(mock.calls.LedgerExpenseRecordDelete, callInfo)
	mock.lockLedgerExpenseRecordDelete.Unlock()
	return mock.LedgerExpenseRecordDeleteFunc(ctx, params)
}

// LedgerExpenseRecordDeleteCalls gets all the calls that were made to LedgerExpenseRecordDelete.
// Check the length with:
//
//	len(mockedLedgersInvoker.LedgerExpenseRecordDeleteCalls())
func (mock *LedgersInvoker) LedgerExpenseRecordDeleteCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseRecordDeleteParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseRecordDeleteParams
	}
	mock.lockLedgerExpenseRecordDelete.RLock()
	calls = mock.calls.LedgerExpenseRecordDelete
	mock.lockLedgerExpenseRecordDelete.RUnlock()
	return calls
}

// LedgerList calls LedgerListFunc.
func (mock *LedgersInvoker) LedgerList(ctx context.Context) (*server.LedgerListOK, error) {
	if mock.LedgerListFunc == nil {
		panic("LedgersInvoker.LedgerListFunc: method is nil but LedgersInvoker.LedgerList was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLedgerList.Lock()
	mock.calls.LedgerList = append(mock.calls.LedgerList, callInfo)
	mock.lockLedgerList.Unlock()
	return mock.LedgerListFunc(ctx)
}

// LedgerListCalls gets all the calls that were made to LedgerList.
// Check the length with:
//
//	len(mockedLedgersInvoker.LedgerListCalls())
func (mock *LedgersInvoker) LedgerListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLedgerList.RLock()
	calls = mock.calls.LedgerList
	mock.lockLedgerList.RUnlock()
	return calls
}

// LedgerMemberAdd calls LedgerMemberAddFunc.
func (mock *LedgersInvoker) LedgerMemberAdd(ctx context.Context, request *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error {
	if mock.LedgerMemberAddFunc == nil {
		panic("LedgersInvoker.LedgerMemberAddFunc: method is nil but LedgersInvoker.LedgerMemberAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.LedgerMemberAddReq
		Params  server.LedgerMemberAddParams
	}{
		Ctx:     ctx,
		Request: request,
		Params:  params,
	}
	mock.lockLedgerMemberAdd.Lock()
	mock.calls.LedgerMemberAdd = append(mock.calls.LedgerMemberAdd, callInfo)
	mock.lockLedgerMemberAdd.Unlock()
	return mock.LedgerMemberAddFunc(ctx, request, params)
}

// LedgerMemberAddCalls gets all the calls that were made to LedgerMemberAdd.
// Check the length with:
//
//	len(mockedLedgersInvoker.LedgerMemberAddCalls())
func (mock *LedgersInvoker) LedgerMemberAddCalls() []struct {
	Ctx     context.Context
	Request *server.LedgerMemberAddReq
	Params  server.LedgerMemberAddParams
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.LedgerMemberAddReq
		Params  server.LedgerMemberAddParams
	}
	mock.lockLedgerMemberAdd.RLock()
	calls = mock.calls.LedgerMemberAdd
	mock.lockLedgerMemberAdd.RUnlock()
	return calls
}

// LedgerMemberList calls LedgerMemberListFunc.
func (mock *LedgersInvoker) LedgerMemberList(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error) {
	if mock.LedgerMemberListFunc == nil {
		panic("LedgersInvoker.LedgerMemberListFunc: method is nil but LedgersInvoker.LedgerMemberList was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerMemberListParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerMemberList.Lock()
	mock.calls.LedgerMemberList = append(mock.calls.LedgerMemberList, callInfo)
	mock.lockLedgerMemberList.Unlock()
	return mock.LedgerMemberListFunc(ctx, params)
}

// LedgerMemberListCalls gets all the calls that were made to LedgerMemberList.
// Check the length with:
//
//	len(mockedLedgersInvoker.LedgerMemberListCalls())
func (mock *LedgersInvoker) LedgerMemberListCalls() []struct {
	Ctx    context.Context
	Params server.LedgerMemberListParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerMemberListParams
	}
	mock.lockLedgerMemberList.RLock()
	calls = mock.calls.LedgerMemberList
	mock.lockLedgerMemberList.RUnlock()
	return calls
}

// Ensure that UsersInvoker does implement server.UsersInvoker.
// If this is not the case, regenerate this file with mockery.
var _ server.UsersInvoker = &UsersInvoker{}

// UsersInvoker is a mock implementation of server.UsersInvoker.
//
//	func TestSomethingThatUsesUsersInvoker(t *testing.T) {
//
//		// make and configure a mocked server.UsersInvoker
//		mockedUsersInvoker := &UsersInvoker{
//			AuthenticationLoginFunc: func(ctx context.Context, request *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error) {
//				panic("mock out the AuthenticationLogin method")
//			},
//			AuthenticationWhoAmIFunc: func(ctx context.Context) (*server.AuthenticationWhoAmIOK, error) {
//				panic("mock out the AuthenticationWhoAmI method")
//			},
//			UserRegisterFunc: func(ctx context.Context, request *server.UserRegisterReq) (*server.UserRegisterOK, error) {
//				panic("mock out the UserRegister method")
//			},
//		}
//
//		// use mockedUsersInvoker in code that requires server.UsersInvoker
//		// and then make assertions.
//
//	}
type UsersInvoker struct {
	// AuthenticationLoginFunc mocks the AuthenticationLogin method.
	AuthenticationLoginFunc func(ctx context.Context, request *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error)

	// AuthenticationWhoAmIFunc mocks the AuthenticationWhoAmI method.
	AuthenticationWhoAmIFunc func(ctx context.Context) (*server.AuthenticationWhoAmIOK, error)

	// UserRegisterFunc mocks the UserRegister method.
	UserRegisterFunc func(ctx context.Context, request *server.UserRegisterReq) (*server.UserRegisterOK, error)

	// calls tracks calls to the methods.
	calls struct {
		// AuthenticationLogin holds details about calls to the AuthenticationLogin method.
		AuthenticationLogin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.AuthenticationLoginReq
		}
		// AuthenticationWhoAmI holds details about calls to the AuthenticationWhoAmI method.
		AuthenticationWhoAmI []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UserRegister holds details about calls to the UserRegister method.
		UserRegister []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *server.UserRegisterReq
		}
	}
	lockAuthenticationLogin  sync.RWMutex
	lockAuthenticationWhoAmI sync.RWMutex
	lockUserRegister         sync.RWMutex
}

// AuthenticationLogin calls AuthenticationLoginFunc.
func (mock *UsersInvoker) AuthenticationLogin(ctx context.Context, request *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error) {
	if mock.AuthenticationLoginFunc == nil {
		panic("UsersInvoker.AuthenticationLoginFunc: method is nil but UsersInvoker.AuthenticationLogin was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.AuthenticationLoginReq
	}{
		Ctx:     ctx,
		Request: request,
	}
	mock.lockAuthenticationLogin.Lock()
	mock.calls.AuthenticationLogin = append(mock.calls.AuthenticationLogin, callInfo)
	mock.lockAuthenticationLogin.Unlock()
	return mock.AuthenticationLoginFunc(ctx, request)
}

// AuthenticationLoginCalls gets all the calls that were made to AuthenticationLogin.
// Check the length with:
//
//	len(mockedUsersInvoker.AuthenticationLoginCalls())
func (mock *UsersInvoker) AuthenticationLoginCalls() []struct {
	Ctx     context.Context
	Request *server.AuthenticationLoginReq
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.AuthenticationLoginReq
	}
	mock.lockAuthenticationLogin.RLock()
	calls = mock.calls.AuthenticationLogin
	mock.lockAuthenticationLogin.RUnlock()
	return calls
}

// AuthenticationWhoAmI calls AuthenticationWhoAmIFunc.
func (mock *UsersInvoker) AuthenticationWhoAmI(ctx context.Context) (*server.AuthenticationWhoAmIOK, error) {
	if mock.AuthenticationWhoAmIFunc == nil {
		panic("UsersInvoker.AuthenticationWhoAmIFunc: method is nil but UsersInvoker.AuthenticationWhoAmI was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAuthenticationWhoAmI.Lock()
	mock.calls.AuthenticationWhoAmI = append(mock.calls.AuthenticationWhoAmI, callInfo)
	mock.lockAuthenticationWhoAmI.Unlock()
	return mock.AuthenticationWhoAmIFunc(ctx)
}

// AuthenticationWhoAmICalls gets all the calls that were made to AuthenticationWhoAmI.
// Check the length with:
//
//	len(mockedUsersInvoker.AuthenticationWhoAmICalls())
func (mock *UsersInvoker) AuthenticationWhoAmICalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAuthenticationWhoAmI.RLock()
	calls = mock.calls.AuthenticationWhoAmI
	mock.lockAuthenticationWhoAmI.RUnlock()
	return calls
}

// UserRegister calls UserRegisterFunc.
func (mock *UsersInvoker) UserRegister(ctx context.Context, request *server.UserRegisterReq) (*server.UserRegisterOK, error) {
	if mock.UserRegisterFunc == nil {
		panic("UsersInvoker.UserRegisterFunc: method is nil but UsersInvoker.UserRegister was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *server.UserRegisterReq
	}{
		Ctx:     ctx,
		Request: request,
	}
	mock.lockUserRegister.Lock()
	mock.calls.UserRegister = append(mock.calls.UserRegister, callInfo)
	mock.lockUserRegister.Unlock()
	return mock.UserRegisterFunc(ctx, request)
}

// UserRegisterCalls gets all the calls that were made to UserRegister.
// Check the length with:
//
//	len(mockedUsersInvoker.UserRegisterCalls())
func (mock *UsersInvoker) UserRegisterCalls() []struct {
	Ctx     context.Context
	Request *server.UserRegisterReq
} {
	var calls []struct {
		Ctx     context.Context
		Request *server.UserRegisterReq
	}
	mock.lockUserRegister.RLock()
	calls = mock.calls.UserRegister
	mock.lockUserRegister.RUnlock()
	return calls
}

// Ensure that errorHandler does implement server.errorHandler.
// If this is not the case, regenerate this file with mockery.
var _ server.errorHandler = &errorHandler{}

// errorHandler is a mock implementation of server.errorHandler.
//
//	func TestSomethingThatUseserrorHandler(t *testing.T) {
//
//		// make and configure a mocked server.errorHandler
//		mockederrorHandler := &errorHandler{
//			NewErrorFunc: func(ctx context.Context, err error) *server.ErrorResponseStatusCode {
//				panic("mock out the NewError method")
//			},
//		}
//
//		// use mockederrorHandler in code that requires server.errorHandler
//		// and then make assertions.
//
//	}
type errorHandler struct {
	// NewErrorFunc mocks the NewError method.
	NewErrorFunc func(ctx context.Context, err error) *server.ErrorResponseStatusCode

	// calls tracks calls to the methods.
	calls struct {
		// NewError holds details about calls to the NewError method.
		NewError []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Err is the err argument value.
			Err error
		}
	}
	lockNewError sync.RWMutex
}

// NewError calls NewErrorFunc.
func (mock *errorHandler) NewError(ctx context.Context, err error) *server.ErrorResponseStatusCode {
	if mock.NewErrorFunc == nil {
		panic("errorHandler.NewErrorFunc: method is nil but errorHandler.NewError was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Err error
	}{
		Ctx: ctx,
		Err: err,
	}
	mock.lockNewError.Lock()
	mock.calls.NewError = append(mock.calls.NewError, callInfo)
	mock.lockNewError.Unlock()
	return mock.NewErrorFunc(ctx, err)
}

// NewErrorCalls gets all the calls that were made to NewError.
// Check the length with:
//
//	len(mockederrorHandler.NewErrorCalls())
func (mock *errorHandler) NewErrorCalls() []struct {
	Ctx context.Context
	Err error
} {
	var calls []struct {
		Ctx context.Context
		Err error
	}
	mock.lockNewError.RLock()
	calls = mock.calls.NewError
	mock.lockNewError.RUnlock()
	return calls
}

// Ensure that SecurityHandler does implement server.SecurityHandler.
// If this is not the case, regenerate this file with mockery.
var _ server.SecurityHandler = &SecurityHandler{}

// SecurityHandler is a mock implementation of server.SecurityHandler.
//
//	func TestSomethingThatUsesSecurityHandler(t *testing.T) {
//
//		// make and configure a mocked server.SecurityHandler
//		mockedSecurityHandler := &SecurityHandler{
//			HandleCookieAuthFunc: func(ctx context.Context, operationName server.OperationName, t server.CookieAuth) (context.Context, error) {
//				panic("mock out the HandleCookieAuth method")
//			},
//		}
//
//		// use mockedSecurityHandler in code that requires server.SecurityHandler
//		// and then make assertions.
//
//	}
type SecurityHandler struct {
	// HandleCookieAuthFunc mocks the HandleCookieAuth method.
	HandleCookieAuthFunc func(ctx context.Context, operationName server.OperationName, t server.CookieAuth) (context.Context, error)

	// calls tracks calls to the methods.
	calls struct {
		// HandleCookieAuth holds details about calls to the HandleCookieAuth method.
		HandleCookieAuth []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OperationName is the operationName argument value.
			OperationName server.OperationName
			// T is the t argument value.
			T server.CookieAuth
		}
	}
	lockHandleCookieAuth sync.RWMutex
}

// HandleCookieAuth calls HandleCookieAuthFunc.
func (mock *SecurityHandler) HandleCookieAuth(ctx context.Context, operationName server.OperationName, t server.CookieAuth) (context.Context, error) {
	if mock.HandleCookieAuthFunc == nil {
		panic("SecurityHandler.HandleCookieAuthFunc: method is nil but SecurityHandler.HandleCookieAuth was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		OperationName server.OperationName
		T             server.CookieAuth
	}{
		Ctx:           ctx,
		OperationName: operationName,
		T:             t,
	}
	mock.lockHandleCookieAuth.Lock()
	mock.calls.HandleCookieAuth = append(mock.calls.HandleCookieAuth, callInfo)
	mock.lockHandleCookieAuth.Unlock()
	return mock.HandleCookieAuthFunc(ctx, operationName, t)
}

// HandleCookieAuthCalls gets all the calls that were made to HandleCookieAuth.
// Check the length with:
//
//	len(mockedSecurityHandler.HandleCookieAuthCalls())
func (mock *SecurityHandler) HandleCookieAuthCalls() []struct {
	Ctx           context.Context
	OperationName server.OperationName
	T             server.CookieAuth
} {
	var calls []struct {
		Ctx           context.Context
		OperationName server.OperationName
		T             server.CookieAuth
	}
	mock.lockHandleCookieAuth.RLock()
	calls = mock.calls.HandleCookieAuth
	mock.lockHandleCookieAuth.RUnlock()
	return calls
}

// Ensure that SecuritySource does implement server.SecuritySource.
// If this is not the case, regenerate this file with mockery.
var _ server.SecuritySource = &SecuritySource{}

// SecuritySource is a mock implementation of server.SecuritySource.
//
//	func TestSomethingThatUsesSecuritySource(t *testing.T) {
//
//		// make and configure a mocked server.SecuritySource
//		mockedSecuritySource := &SecuritySource{
//			CookieAuthFunc: func(ctx context.Context, operationName server.OperationName) (server.CookieAuth, error) {
//				panic("mock out the CookieAuth method")
//			},
//		}
//
//		// use mockedSecuritySource in code that requires server.SecuritySource
//		// and then make assertions.
//
//	}
type SecuritySource struct {
	// CookieAuthFunc mocks the CookieAuth method.
	CookieAuthFunc func(ctx context.Context, operationName server.OperationName) (server.CookieAuth, error)

	// calls tracks calls to the methods.
	calls struct {
		// CookieAuth holds details about calls to the CookieAuth method.
		CookieAuth []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OperationName is the operationName argument value.
			OperationName server.OperationName
		}
	}
	lockCookieAuth sync.RWMutex
}

// CookieAuth calls CookieAuthFunc.
func (mock *SecuritySource) CookieAuth(ctx context.Context, operationName server.OperationName) (server.CookieAuth, error) {
	if mock.CookieAuthFunc == nil {
		panic("SecuritySource.CookieAuthFunc: method is nil but SecuritySource.CookieAuth was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		OperationName server.OperationName
	}{
		Ctx:           ctx,
		OperationName: operationName,
	}
	mock.lockCookieAuth.Lock()
	mock.calls.CookieAuth = append(mock.calls.CookieAuth, callInfo)
	mock.lockCookieAuth.Unlock()
	return mock.CookieAuthFunc(ctx, operationName)
}

// CookieAuthCalls gets all the calls that were made to CookieAuth.
// Check the length with:
//
//	len(mockedSecuritySource.CookieAuthCalls())
func (mock *SecuritySource) CookieAuthCalls() []struct {
	Ctx           context.Context
	OperationName server.OperationName
} {
	var calls []struct {
		Ctx           context.Context
		OperationName server.OperationName
	}
	mock.lockCookieAuth.RLock()
	calls = mock.calls.CookieAuth
	mock.lockCookieAuth.RUnlock()
	return calls
}

// Ensure that Handler does implement server.Handler.
// If this is not the case, regenerate this file with mockery.
var _ server.Handler = &Handler{}

// Handler is a mock implementation of server.Handler.
//
//	func TestSomethingThatUsesHandler(t *testing.T) {
//
//		// make and configure a mocked server.Handler
//		mockedHandler := &Handler{
//			AuthenticationLoginFunc: func(ctx context.Context, req *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error) {
//				panic("mock out the AuthenticationLogin method")
//			},
//			AuthenticationWhoAmIFunc: func(ctx context.Context) (*server.AuthenticationWhoAmIOK, error) {
//				panic("mock out the AuthenticationWhoAmI method")
//			},
//			HealthcheckFunc: func(ctx context.Context) error {
//				panic("mock out the Healthcheck method")
//			},
//			LedgerCreateFunc: func(ctx context.Context, req *server.LedgerCreateReq) (*server.LedgerCreateOK, error) {
//				panic("mock out the LedgerCreate method")
//			},
//			LedgerExpenseCreateFunc: func(ctx context.Context, req *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error) {
//				panic("mock out the LedgerExpenseCreate method")
//			},
//			LedgerExpenseGetFunc: func(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error) {
//				panic("mock out the LedgerExpenseGet method")
//			},
//			LedgerExpenseListFunc: func(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error) {
//				panic("mock out the LedgerExpenseList method")
//			},
//			LedgerExpenseRecordCreateFunc: func(ctx context.Context, req *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error) {
//				panic("mock out the LedgerExpenseRecordCreate method")
//			},
//			LedgerExpenseRecordDeleteFunc: func(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error {
//				panic("mock out the LedgerExpenseRecordDelete method")
//			},
//			LedgerListFunc: func(ctx context.Context) (*server.LedgerListOK, error) {
//				panic("mock out the LedgerList method")
//			},
//			LedgerMemberAddFunc: func(ctx context.Context, req *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error {
//				panic("mock out the LedgerMemberAdd method")
//			},
//			LedgerMemberListFunc: func(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error) {
//				panic("mock out the LedgerMemberList method")
//			},
//			NewErrorFunc: func(ctx context.Context, err error) *server.ErrorResponseStatusCode {
//				panic("mock out the NewError method")
//			},
//			UserRegisterFunc: func(ctx context.Context, req *server.UserRegisterReq) (*server.UserRegisterOK, error) {
//				panic("mock out the UserRegister method")
//			},
//		}
//
//		// use mockedHandler in code that requires server.Handler
//		// and then make assertions.
//
//	}
type Handler struct {
	// AuthenticationLoginFunc mocks the AuthenticationLogin method.
	AuthenticationLoginFunc func(ctx context.Context, req *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error)

	// AuthenticationWhoAmIFunc mocks the AuthenticationWhoAmI method.
	AuthenticationWhoAmIFunc func(ctx context.Context) (*server.AuthenticationWhoAmIOK, error)

	// HealthcheckFunc mocks the Healthcheck method.
	HealthcheckFunc func(ctx context.Context) error

	// LedgerCreateFunc mocks the LedgerCreate method.
	LedgerCreateFunc func(ctx context.Context, req *server.LedgerCreateReq) (*server.LedgerCreateOK, error)

	// LedgerExpenseCreateFunc mocks the LedgerExpenseCreate method.
	LedgerExpenseCreateFunc func(ctx context.Context, req *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error)

	// LedgerExpenseGetFunc mocks the LedgerExpenseGet method.
	LedgerExpenseGetFunc func(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error)

	// LedgerExpenseListFunc mocks the LedgerExpenseList method.
	LedgerExpenseListFunc func(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error)

	// LedgerExpenseRecordCreateFunc mocks the LedgerExpenseRecordCreate method.
	LedgerExpenseRecordCreateFunc func(ctx context.Context, req *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error)

	// LedgerExpenseRecordDeleteFunc mocks the LedgerExpenseRecordDelete method.
	LedgerExpenseRecordDeleteFunc func(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error

	// LedgerListFunc mocks the LedgerList method.
	LedgerListFunc func(ctx context.Context) (*server.LedgerListOK, error)

	// LedgerMemberAddFunc mocks the LedgerMemberAdd method.
	LedgerMemberAddFunc func(ctx context.Context, req *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error

	// LedgerMemberListFunc mocks the LedgerMemberList method.
	LedgerMemberListFunc func(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error)

	// NewErrorFunc mocks the NewError method.
	NewErrorFunc func(ctx context.Context, err error) *server.ErrorResponseStatusCode

	// UserRegisterFunc mocks the UserRegister method.
	UserRegisterFunc func(ctx context.Context, req *server.UserRegisterReq) (*server.UserRegisterOK, error)

	// calls tracks calls to the methods.
	calls struct {
		// AuthenticationLogin holds details about calls to the AuthenticationLogin method.
		AuthenticationLogin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.AuthenticationLoginReq
		}
		// AuthenticationWhoAmI holds details about calls to the AuthenticationWhoAmI method.
		AuthenticationWhoAmI []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Healthcheck holds details about calls to the Healthcheck method.
		Healthcheck []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LedgerCreate holds details about calls to the LedgerCreate method.
		LedgerCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.LedgerCreateReq
		}
		// LedgerExpenseCreate holds details about calls to the LedgerExpenseCreate method.
		LedgerExpenseCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.Expense
			// Params is the params argument value.
			Params server.LedgerExpenseCreateParams
		}
		// LedgerExpenseGet holds details about calls to the LedgerExpenseGet method.
		LedgerExpenseGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseGetParams
		}
		// LedgerExpenseList holds details about calls to the LedgerExpenseList method.
		LedgerExpenseList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseListParams
		}
		// LedgerExpenseRecordCreate holds details about calls to the LedgerExpenseRecordCreate method.
		LedgerExpenseRecordCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.LedgerExpenseRecordCreateReq
			// Params is the params argument value.
			Params server.LedgerExpenseRecordCreateParams
		}
		// LedgerExpenseRecordDelete holds details about calls to the LedgerExpenseRecordDelete method.
		LedgerExpenseRecordDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseRecordDeleteParams
		}
		// LedgerList holds details about calls to the LedgerList method.
		LedgerList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LedgerMemberAdd holds details about calls to the LedgerMemberAdd method.
		LedgerMemberAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.LedgerMemberAddReq
			// Params is the params argument value.
			Params server.LedgerMemberAddParams
		}
		// LedgerMemberList holds details about calls to the LedgerMemberList method.
		LedgerMemberList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerMemberListParams
		}
		// NewError holds details about calls to the NewError method.
		NewError []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Err is the err argument value.
			Err error
		}
		// UserRegister holds details about calls to the UserRegister method.
		UserRegister []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.UserRegisterReq
		}
	}
	lockAuthenticationLogin       sync.RWMutex
	lockAuthenticationWhoAmI      sync.RWMutex
	lockHealthcheck               sync.RWMutex
	lockLedgerCreate              sync.RWMutex
	lockLedgerExpenseCreate       sync.RWMutex
	lockLedgerExpenseGet          sync.RWMutex
	lockLedgerExpenseList         sync.RWMutex
	lockLedgerExpenseRecordCreate sync.RWMutex
	lockLedgerExpenseRecordDelete sync.RWMutex
	lockLedgerList                sync.RWMutex
	lockLedgerMemberAdd           sync.RWMutex
	lockLedgerMemberList          sync.RWMutex
	lockNewError                  sync.RWMutex
	lockUserRegister              sync.RWMutex
}

// AuthenticationLogin calls AuthenticationLoginFunc.
func (mock *Handler) AuthenticationLogin(ctx context.Context, req *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error) {
	if mock.AuthenticationLoginFunc == nil {
		panic("Handler.AuthenticationLoginFunc: method is nil but Handler.AuthenticationLogin was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *server.AuthenticationLoginReq
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockAuthenticationLogin.Lock()
	mock.calls.AuthenticationLogin = append(mock.calls.AuthenticationLogin, callInfo)
	mock.lockAuthenticationLogin.Unlock()
	return mock.AuthenticationLoginFunc(ctx, req)
}

// AuthenticationLoginCalls gets all the calls that were made to AuthenticationLogin.
// Check the length with:
//
//	len(mockedHandler.AuthenticationLoginCalls())
func (mock *Handler) AuthenticationLoginCalls() []struct {
	Ctx context.Context
	Req *server.AuthenticationLoginReq
} {
	var calls []struct {
		Ctx context.Context
		Req *server.AuthenticationLoginReq
	}
	mock.lockAuthenticationLogin.RLock()
	calls = mock.calls.AuthenticationLogin
	mock.lockAuthenticationLogin.RUnlock()
	return calls
}

// AuthenticationWhoAmI calls AuthenticationWhoAmIFunc.
func (mock *Handler) AuthenticationWhoAmI(ctx context.Context) (*server.AuthenticationWhoAmIOK, error) {
	if mock.AuthenticationWhoAmIFunc == nil {
		panic("Handler.AuthenticationWhoAmIFunc: method is nil but Handler.AuthenticationWhoAmI was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAuthenticationWhoAmI.Lock()
	mock.calls.AuthenticationWhoAmI = append(mock.calls.AuthenticationWhoAmI, callInfo)
	mock.lockAuthenticationWhoAmI.Unlock()
	return mock.AuthenticationWhoAmIFunc(ctx)
}

// AuthenticationWhoAmICalls gets all the calls that were made to AuthenticationWhoAmI.
// Check the length with:
//
//	len(mockedHandler.AuthenticationWhoAmICalls())
func (mock *Handler) AuthenticationWhoAmICalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAuthenticationWhoAmI.RLock()
	calls = mock.calls.AuthenticationWhoAmI
	mock.lockAuthenticationWhoAmI.RUnlock()
	return calls
}

// Healthcheck calls HealthcheckFunc.
func (mock *Handler) Healthcheck(ctx context.Context) error {
	if mock.HealthcheckFunc == nil {
		panic("Handler.HealthcheckFunc: method is nil but Handler.Healthcheck was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHealthcheck.Lock()
	mock.calls.Healthcheck = append(mock.calls.Healthcheck, callInfo)
	mock.lockHealthcheck.Unlock()
	return mock.HealthcheckFunc(ctx)
}

// HealthcheckCalls gets all the calls that were made to Healthcheck.
// Check the length with:
//
//	len(mockedHandler.HealthcheckCalls())
func (mock *Handler) HealthcheckCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHealthcheck.RLock()
	calls = mock.calls.Healthcheck
	mock.lockHealthcheck.RUnlock()
	return calls
}

// LedgerCreate calls LedgerCreateFunc.
func (mock *Handler) LedgerCreate(ctx context.Context, req *server.LedgerCreateReq) (*server.LedgerCreateOK, error) {
	if mock.LedgerCreateFunc == nil {
		panic("Handler.LedgerCreateFunc: method is nil but Handler.LedgerCreate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *server.LedgerCreateReq
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockLedgerCreate.Lock()
	mock.calls.LedgerCreate = append(mock.calls.LedgerCreate, callInfo)
	mock.lockLedgerCreate.Unlock()
	return mock.LedgerCreateFunc(ctx, req)
}

// LedgerCreateCalls gets all the calls that were made to LedgerCreate.
// Check the length with:
//
//	len(mockedHandler.LedgerCreateCalls())
func (mock *Handler) LedgerCreateCalls() []struct {
	Ctx context.Context
	Req *server.LedgerCreateReq
} {
	var calls []struct {
		Ctx context.Context
		Req *server.LedgerCreateReq
	}
	mock.lockLedgerCreate.RLock()
	calls = mock.calls.LedgerCreate
	mock.lockLedgerCreate.RUnlock()
	return calls
}

// LedgerExpenseCreate calls LedgerExpenseCreateFunc.
func (mock *Handler) LedgerExpenseCreate(ctx context.Context, req *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error) {
	if mock.LedgerExpenseCreateFunc == nil {
		panic("Handler.LedgerExpenseCreateFunc: method is nil but Handler.LedgerExpenseCreate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Req    *server.Expense
		Params server.LedgerExpenseCreateParams
	}{
		Ctx:    ctx,
		Req:    req,
		Params: params,
	}
	mock.lockLedgerExpenseCreate.Lock()
	mock.calls.LedgerExpenseCreate = append(mock.calls.LedgerExpenseCreate, callInfo)
	mock.lockLedgerExpenseCreate.Unlock()
	return mock.LedgerExpenseCreateFunc(ctx, req, params)
}

// LedgerExpenseCreateCalls gets all the calls that were made to LedgerExpenseCreate.
// Check the length with:
//
//	len(mockedHandler.LedgerExpenseCreateCalls())
func (mock *Handler) LedgerExpenseCreateCalls() []struct {
	Ctx    context.Context
	Req    *server.Expense
	Params server.LedgerExpenseCreateParams
} {
	var calls []struct {
		Ctx    context.Context
		Req    *server.Expense
		Params server.LedgerExpenseCreateParams
	}
	mock.lockLedgerExpenseCreate.RLock()
	calls = mock.calls.LedgerExpenseCreate
	mock.lockLedgerExpenseCreate.RUnlock()
	return calls
}

// LedgerExpenseGet calls LedgerExpenseGetFunc.
func (mock *Handler) LedgerExpenseGet(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error) {
	if mock.LedgerExpenseGetFunc == nil {
		panic("Handler.LedgerExpenseGetFunc: method is nil but Handler.LedgerExpenseGet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseGetParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseGet.Lock()
	mock.calls.LedgerExpenseGet = append(mock.calls.LedgerExpenseGet, callInfo)
	mock.lockLedgerExpenseGet.Unlock()
	return mock.LedgerExpenseGetFunc(ctx, params)
}

// LedgerExpenseGetCalls gets all the calls that were made to LedgerExpenseGet.
// Check the length with:
//
//	len(mockedHandler.LedgerExpenseGetCalls())
func (mock *Handler) LedgerExpenseGetCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseGetParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseGetParams
	}
	mock.lockLedgerExpenseGet.RLock()
	calls = mock.calls.LedgerExpenseGet
	mock.lockLedgerExpenseGet.RUnlock()
	return calls
}

// LedgerExpenseList calls LedgerExpenseListFunc.
func (mock *Handler) LedgerExpenseList(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error) {
	if mock.LedgerExpenseListFunc == nil {
		panic("Handler.LedgerExpenseListFunc: method is nil but Handler.LedgerExpenseList was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseListParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseList.Lock()
	mock.calls.LedgerExpenseList = append(mock.calls.LedgerExpenseList, callInfo)
	mock.lockLedgerExpenseList.Unlock()
	return mock.LedgerExpenseListFunc(ctx, params)
}

// LedgerExpenseListCalls gets all the calls that were made to LedgerExpenseList.
// Check the length with:
//
//	len(mockedHandler.LedgerExpenseListCalls())
func (mock *Handler) LedgerExpenseListCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseListParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseListParams
	}
	mock.lockLedgerExpenseList.RLock()
	calls = mock.calls.LedgerExpenseList
	mock.lockLedgerExpenseList.RUnlock()
	return calls
}

// LedgerExpenseRecordCreate calls LedgerExpenseRecordCreateFunc.
func (mock *Handler) LedgerExpenseRecordCreate(ctx context.Context, req *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error) {
	if mock.LedgerExpenseRecordCreateFunc == nil {
		panic("Handler.LedgerExpenseRecordCreateFunc: method is nil but Handler.LedgerExpenseRecordCreate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Req    *server.LedgerExpenseRecordCreateReq
		Params server.LedgerExpenseRecordCreateParams
	}{
		Ctx:    ctx,
		Req:    req,
		Params: params,
	}
	mock.lockLedgerExpenseRecordCreate.Lock()
	mock.calls.LedgerExpenseRecordCreate = append(mock.calls.LedgerExpenseRecordCreate, callInfo)
	mock.lockLedgerExpenseRecordCreate.Unlock()
	return mock.LedgerExpenseRecordCreateFunc(ctx, req, params)
}

// LedgerExpenseRecordCreateCalls gets all the calls that were made to LedgerExpenseRecordCreate.
// Check the length with:
//
//	len(mockedHandler.LedgerExpenseRecordCreateCalls())
func (mock *Handler) LedgerExpenseRecordCreateCalls() []struct {
	Ctx    context.Context
	Req    *server.LedgerExpenseRecordCreateReq
	Params server.LedgerExpenseRecordCreateParams
} {
	var calls []struct {
		Ctx    context.Context
		Req    *server.LedgerExpenseRecordCreateReq
		Params server.LedgerExpenseRecordCreateParams
	}
	mock.lockLedgerExpenseRecordCreate.RLock()
	calls = mock.calls.LedgerExpenseRecordCreate
	mock.lockLedgerExpenseRecordCreate.RUnlock()
	return calls
}

// LedgerExpenseRecordDelete calls LedgerExpenseRecordDeleteFunc.
func (mock *Handler) LedgerExpenseRecordDelete(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error {
	if mock.LedgerExpenseRecordDeleteFunc == nil {
		panic("Handler.LedgerExpenseRecordDeleteFunc: method is nil but Handler.LedgerExpenseRecordDelete was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseRecordDeleteParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseRecordDelete.Lock()
	mock.calls.LedgerExpenseRecordDelete = append(mock.calls.LedgerExpenseRecordDelete, callInfo)
	mock.lockLedgerExpenseRecordDelete.Unlock()
	return mock.LedgerExpenseRecordDeleteFunc(ctx, params)
}

// LedgerExpenseRecordDeleteCalls gets all the calls that were made to LedgerExpenseRecordDelete.
// Check the length with:
//
//	len(mockedHandler.LedgerExpenseRecordDeleteCalls())
func (mock *Handler) LedgerExpenseRecordDeleteCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseRecordDeleteParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseRecordDeleteParams
	}
	mock.lockLedgerExpenseRecordDelete.RLock()
	calls = mock.calls.LedgerExpenseRecordDelete
	mock.lockLedgerExpenseRecordDelete.RUnlock()
	return calls
}

// LedgerList calls LedgerListFunc.
func (mock *Handler) LedgerList(ctx context.Context) (*server.LedgerListOK, error) {
	if mock.LedgerListFunc == nil {
		panic("Handler.LedgerListFunc: method is nil but Handler.LedgerList was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLedgerList.Lock()
	mock.calls.LedgerList = append(mock.calls.LedgerList, callInfo)
	mock.lockLedgerList.Unlock()
	return mock.LedgerListFunc(ctx)
}

// LedgerListCalls gets all the calls that were made to LedgerList.
// Check the length with:
//
//	len(mockedHandler.LedgerListCalls())
func (mock *Handler) LedgerListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLedgerList.RLock()
	calls = mock.calls.LedgerList
	mock.lockLedgerList.RUnlock()
	return calls
}

// LedgerMemberAdd calls LedgerMemberAddFunc.
func (mock *Handler) LedgerMemberAdd(ctx context.Context, req *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error {
	if mock.LedgerMemberAddFunc == nil {
		panic("Handler.LedgerMemberAddFunc: method is nil but Handler.LedgerMemberAdd was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Req    *server.LedgerMemberAddReq
		Params server.LedgerMemberAddParams
	}{
		Ctx:    ctx,
		Req:    req,
		Params: params,
	}
	mock.lockLedgerMemberAdd.Lock()
	mock.calls.LedgerMemberAdd = append(mock.calls.LedgerMemberAdd, callInfo)
	mock.lockLedgerMemberAdd.Unlock()
	return mock.LedgerMemberAddFunc(ctx, req, params)
}

// LedgerMemberAddCalls gets all the calls that were made to LedgerMemberAdd.
// Check the length with:
//
//	len(mockedHandler.LedgerMemberAddCalls())
func (mock *Handler) LedgerMemberAddCalls() []struct {
	Ctx    context.Context
	Req    *server.LedgerMemberAddReq
	Params server.LedgerMemberAddParams
} {
	var calls []struct {
		Ctx    context.Context
		Req    *server.LedgerMemberAddReq
		Params server.LedgerMemberAddParams
	}
	mock.lockLedgerMemberAdd.RLock()
	calls = mock.calls.LedgerMemberAdd
	mock.lockLedgerMemberAdd.RUnlock()
	return calls
}

// LedgerMemberList calls LedgerMemberListFunc.
func (mock *Handler) LedgerMemberList(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error) {
	if mock.LedgerMemberListFunc == nil {
		panic("Handler.LedgerMemberListFunc: method is nil but Handler.LedgerMemberList was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerMemberListParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerMemberList.Lock()
	mock.calls.LedgerMemberList = append(mock.calls.LedgerMemberList, callInfo)
	mock.lockLedgerMemberList.Unlock()
	return mock.LedgerMemberListFunc(ctx, params)
}

// LedgerMemberListCalls gets all the calls that were made to LedgerMemberList.
// Check the length with:
//
//	len(mockedHandler.LedgerMemberListCalls())
func (mock *Handler) LedgerMemberListCalls() []struct {
	Ctx    context.Context
	Params server.LedgerMemberListParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerMemberListParams
	}
	mock.lockLedgerMemberList.RLock()
	calls = mock.calls.LedgerMemberList
	mock.lockLedgerMemberList.RUnlock()
	return calls
}

// NewError calls NewErrorFunc.
func (mock *Handler) NewError(ctx context.Context, err error) *server.ErrorResponseStatusCode {
	if mock.NewErrorFunc == nil {
		panic("Handler.NewErrorFunc: method is nil but Handler.NewError was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Err error
	}{
		Ctx: ctx,
		Err: err,
	}
	mock.lockNewError.Lock()
	mock.calls.NewError = append(mock.calls.NewError, callInfo)
	mock.lockNewError.Unlock()
	return mock.NewErrorFunc(ctx, err)
}

// NewErrorCalls gets all the calls that were made to NewError.
// Check the length with:
//
//	len(mockedHandler.NewErrorCalls())
func (mock *Handler) NewErrorCalls() []struct {
	Ctx context.Context
	Err error
} {
	var calls []struct {
		Ctx context.Context
		Err error
	}
	mock.lockNewError.RLock()
	calls = mock.calls.NewError
	mock.lockNewError.RUnlock()
	return calls
}

// UserRegister calls UserRegisterFunc.
func (mock *Handler) UserRegister(ctx context.Context, req *server.UserRegisterReq) (*server.UserRegisterOK, error) {
	if mock.UserRegisterFunc == nil {
		panic("Handler.UserRegisterFunc: method is nil but Handler.UserRegister was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *server.UserRegisterReq
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockUserRegister.Lock()
	mock.calls.UserRegister = append(mock.calls.UserRegister, callInfo)
	mock.lockUserRegister.Unlock()
	return mock.UserRegisterFunc(ctx, req)
}

// UserRegisterCalls gets all the calls that were made to UserRegister.
// Check the length with:
//
//	len(mockedHandler.UserRegisterCalls())
func (mock *Handler) UserRegisterCalls() []struct {
	Ctx context.Context
	Req *server.UserRegisterReq
} {
	var calls []struct {
		Ctx context.Context
		Req *server.UserRegisterReq
	}
	mock.lockUserRegister.RLock()
	calls = mock.calls.UserRegister
	mock.lockUserRegister.RUnlock()
	return calls
}

// Ensure that HealthcheckHandler does implement server.HealthcheckHandler.
// If this is not the case, regenerate this file with mockery.
var _ server.HealthcheckHandler = &HealthcheckHandler{}

// HealthcheckHandler is a mock implementation of server.HealthcheckHandler.
//
//	func TestSomethingThatUsesHealthcheckHandler(t *testing.T) {
//
//		// make and configure a mocked server.HealthcheckHandler
//		mockedHealthcheckHandler := &HealthcheckHandler{
//			HealthcheckFunc: func(ctx context.Context) error {
//				panic("mock out the Healthcheck method")
//			},
//		}
//
//		// use mockedHealthcheckHandler in code that requires server.HealthcheckHandler
//		// and then make assertions.
//
//	}
type HealthcheckHandler struct {
	// HealthcheckFunc mocks the Healthcheck method.
	HealthcheckFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// Healthcheck holds details about calls to the Healthcheck method.
		Healthcheck []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockHealthcheck sync.RWMutex
}

// Healthcheck calls HealthcheckFunc.
func (mock *HealthcheckHandler) Healthcheck(ctx context.Context) error {
	if mock.HealthcheckFunc == nil {
		panic("HealthcheckHandler.HealthcheckFunc: method is nil but HealthcheckHandler.Healthcheck was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHealthcheck.Lock()
	mock.calls.Healthcheck = append(mock.calls.Healthcheck, callInfo)
	mock.lockHealthcheck.Unlock()
	return mock.HealthcheckFunc(ctx)
}

// HealthcheckCalls gets all the calls that were made to Healthcheck.
// Check the length with:
//
//	len(mockedHealthcheckHandler.HealthcheckCalls())
func (mock *HealthcheckHandler) HealthcheckCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHealthcheck.RLock()
	calls = mock.calls.Healthcheck
	mock.lockHealthcheck.RUnlock()
	return calls
}

// Ensure that LedgersHandler does implement server.LedgersHandler.
// If this is not the case, regenerate this file with mockery.
var _ server.LedgersHandler = &LedgersHandler{}

// LedgersHandler is a mock implementation of server.LedgersHandler.
//
//	func TestSomethingThatUsesLedgersHandler(t *testing.T) {
//
//		// make and configure a mocked server.LedgersHandler
//		mockedLedgersHandler := &LedgersHandler{
//			LedgerCreateFunc: func(ctx context.Context, req *server.LedgerCreateReq) (*server.LedgerCreateOK, error) {
//				panic("mock out the LedgerCreate method")
//			},
//			LedgerExpenseCreateFunc: func(ctx context.Context, req *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error) {
//				panic("mock out the LedgerExpenseCreate method")
//			},
//			LedgerExpenseGetFunc: func(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error) {
//				panic("mock out the LedgerExpenseGet method")
//			},
//			LedgerExpenseListFunc: func(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error) {
//				panic("mock out the LedgerExpenseList method")
//			},
//			LedgerExpenseRecordCreateFunc: func(ctx context.Context, req *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error) {
//				panic("mock out the LedgerExpenseRecordCreate method")
//			},
//			LedgerExpenseRecordDeleteFunc: func(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error {
//				panic("mock out the LedgerExpenseRecordDelete method")
//			},
//			LedgerListFunc: func(ctx context.Context) (*server.LedgerListOK, error) {
//				panic("mock out the LedgerList method")
//			},
//			LedgerMemberAddFunc: func(ctx context.Context, req *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error {
//				panic("mock out the LedgerMemberAdd method")
//			},
//			LedgerMemberListFunc: func(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error) {
//				panic("mock out the LedgerMemberList method")
//			},
//		}
//
//		// use mockedLedgersHandler in code that requires server.LedgersHandler
//		// and then make assertions.
//
//	}
type LedgersHandler struct {
	// LedgerCreateFunc mocks the LedgerCreate method.
	LedgerCreateFunc func(ctx context.Context, req *server.LedgerCreateReq) (*server.LedgerCreateOK, error)

	// LedgerExpenseCreateFunc mocks the LedgerExpenseCreate method.
	LedgerExpenseCreateFunc func(ctx context.Context, req *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error)

	// LedgerExpenseGetFunc mocks the LedgerExpenseGet method.
	LedgerExpenseGetFunc func(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error)

	// LedgerExpenseListFunc mocks the LedgerExpenseList method.
	LedgerExpenseListFunc func(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error)

	// LedgerExpenseRecordCreateFunc mocks the LedgerExpenseRecordCreate method.
	LedgerExpenseRecordCreateFunc func(ctx context.Context, req *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error)

	// LedgerExpenseRecordDeleteFunc mocks the LedgerExpenseRecordDelete method.
	LedgerExpenseRecordDeleteFunc func(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error

	// LedgerListFunc mocks the LedgerList method.
	LedgerListFunc func(ctx context.Context) (*server.LedgerListOK, error)

	// LedgerMemberAddFunc mocks the LedgerMemberAdd method.
	LedgerMemberAddFunc func(ctx context.Context, req *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error

	// LedgerMemberListFunc mocks the LedgerMemberList method.
	LedgerMemberListFunc func(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error)

	// calls tracks calls to the methods.
	calls struct {
		// LedgerCreate holds details about calls to the LedgerCreate method.
		LedgerCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.LedgerCreateReq
		}
		// LedgerExpenseCreate holds details about calls to the LedgerExpenseCreate method.
		LedgerExpenseCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.Expense
			// Params is the params argument value.
			Params server.LedgerExpenseCreateParams
		}
		// LedgerExpenseGet holds details about calls to the LedgerExpenseGet method.
		LedgerExpenseGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseGetParams
		}
		// LedgerExpenseList holds details about calls to the LedgerExpenseList method.
		LedgerExpenseList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseListParams
		}
		// LedgerExpenseRecordCreate holds details about calls to the LedgerExpenseRecordCreate method.
		LedgerExpenseRecordCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.LedgerExpenseRecordCreateReq
			// Params is the params argument value.
			Params server.LedgerExpenseRecordCreateParams
		}
		// LedgerExpenseRecordDelete holds details about calls to the LedgerExpenseRecordDelete method.
		LedgerExpenseRecordDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerExpenseRecordDeleteParams
		}
		// LedgerList holds details about calls to the LedgerList method.
		LedgerList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LedgerMemberAdd holds details about calls to the LedgerMemberAdd method.
		LedgerMemberAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.LedgerMemberAddReq
			// Params is the params argument value.
			Params server.LedgerMemberAddParams
		}
		// LedgerMemberList holds details about calls to the LedgerMemberList method.
		LedgerMemberList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params server.LedgerMemberListParams
		}
	}
	lockLedgerCreate              sync.RWMutex
	lockLedgerExpenseCreate       sync.RWMutex
	lockLedgerExpenseGet          sync.RWMutex
	lockLedgerExpenseList         sync.RWMutex
	lockLedgerExpenseRecordCreate sync.RWMutex
	lockLedgerExpenseRecordDelete sync.RWMutex
	lockLedgerList                sync.RWMutex
	lockLedgerMemberAdd           sync.RWMutex
	lockLedgerMemberList          sync.RWMutex
}

// LedgerCreate calls LedgerCreateFunc.
func (mock *LedgersHandler) LedgerCreate(ctx context.Context, req *server.LedgerCreateReq) (*server.LedgerCreateOK, error) {
	if mock.LedgerCreateFunc == nil {
		panic("LedgersHandler.LedgerCreateFunc: method is nil but LedgersHandler.LedgerCreate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *server.LedgerCreateReq
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockLedgerCreate.Lock()
	mock.calls.LedgerCreate = append(mock.calls.LedgerCreate, callInfo)
	mock.lockLedgerCreate.Unlock()
	return mock.LedgerCreateFunc(ctx, req)
}

// LedgerCreateCalls gets all the calls that were made to LedgerCreate.
// Check the length with:
//
//	len(mockedLedgersHandler.LedgerCreateCalls())
func (mock *LedgersHandler) LedgerCreateCalls() []struct {
	Ctx context.Context
	Req *server.LedgerCreateReq
} {
	var calls []struct {
		Ctx context.Context
		Req *server.LedgerCreateReq
	}
	mock.lockLedgerCreate.RLock()
	calls = mock.calls.LedgerCreate
	mock.lockLedgerCreate.RUnlock()
	return calls
}

// LedgerExpenseCreate calls LedgerExpenseCreateFunc.
func (mock *LedgersHandler) LedgerExpenseCreate(ctx context.Context, req *server.Expense, params server.LedgerExpenseCreateParams) (*server.LedgerExpenseCreateOK, error) {
	if mock.LedgerExpenseCreateFunc == nil {
		panic("LedgersHandler.LedgerExpenseCreateFunc: method is nil but LedgersHandler.LedgerExpenseCreate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Req    *server.Expense
		Params server.LedgerExpenseCreateParams
	}{
		Ctx:    ctx,
		Req:    req,
		Params: params,
	}
	mock.lockLedgerExpenseCreate.Lock()
	mock.calls.LedgerExpenseCreate = append(mock.calls.LedgerExpenseCreate, callInfo)
	mock.lockLedgerExpenseCreate.Unlock()
	return mock.LedgerExpenseCreateFunc(ctx, req, params)
}

// LedgerExpenseCreateCalls gets all the calls that were made to LedgerExpenseCreate.
// Check the length with:
//
//	len(mockedLedgersHandler.LedgerExpenseCreateCalls())
func (mock *LedgersHandler) LedgerExpenseCreateCalls() []struct {
	Ctx    context.Context
	Req    *server.Expense
	Params server.LedgerExpenseCreateParams
} {
	var calls []struct {
		Ctx    context.Context
		Req    *server.Expense
		Params server.LedgerExpenseCreateParams
	}
	mock.lockLedgerExpenseCreate.RLock()
	calls = mock.calls.LedgerExpenseCreate
	mock.lockLedgerExpenseCreate.RUnlock()
	return calls
}

// LedgerExpenseGet calls LedgerExpenseGetFunc.
func (mock *LedgersHandler) LedgerExpenseGet(ctx context.Context, params server.LedgerExpenseGetParams) (*server.Expense, error) {
	if mock.LedgerExpenseGetFunc == nil {
		panic("LedgersHandler.LedgerExpenseGetFunc: method is nil but LedgersHandler.LedgerExpenseGet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseGetParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseGet.Lock()
	mock.calls.LedgerExpenseGet = append(mock.calls.LedgerExpenseGet, callInfo)
	mock.lockLedgerExpenseGet.Unlock()
	return mock.LedgerExpenseGetFunc(ctx, params)
}

// LedgerExpenseGetCalls gets all the calls that were made to LedgerExpenseGet.
// Check the length with:
//
//	len(mockedLedgersHandler.LedgerExpenseGetCalls())
func (mock *LedgersHandler) LedgerExpenseGetCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseGetParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseGetParams
	}
	mock.lockLedgerExpenseGet.RLock()
	calls = mock.calls.LedgerExpenseGet
	mock.lockLedgerExpenseGet.RUnlock()
	return calls
}

// LedgerExpenseList calls LedgerExpenseListFunc.
func (mock *LedgersHandler) LedgerExpenseList(ctx context.Context, params server.LedgerExpenseListParams) (*server.LedgerExpenseListOK, error) {
	if mock.LedgerExpenseListFunc == nil {
		panic("LedgersHandler.LedgerExpenseListFunc: method is nil but LedgersHandler.LedgerExpenseList was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseListParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseList.Lock()
	mock.calls.LedgerExpenseList = append(mock.calls.LedgerExpenseList, callInfo)
	mock.lockLedgerExpenseList.Unlock()
	return mock.LedgerExpenseListFunc(ctx, params)
}

// LedgerExpenseListCalls gets all the calls that were made to LedgerExpenseList.
// Check the length with:
//
//	len(mockedLedgersHandler.LedgerExpenseListCalls())
func (mock *LedgersHandler) LedgerExpenseListCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseListParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseListParams
	}
	mock.lockLedgerExpenseList.RLock()
	calls = mock.calls.LedgerExpenseList
	mock.lockLedgerExpenseList.RUnlock()
	return calls
}

// LedgerExpenseRecordCreate calls LedgerExpenseRecordCreateFunc.
func (mock *LedgersHandler) LedgerExpenseRecordCreate(ctx context.Context, req *server.LedgerExpenseRecordCreateReq, params server.LedgerExpenseRecordCreateParams) (*server.Expense, error) {
	if mock.LedgerExpenseRecordCreateFunc == nil {
		panic("LedgersHandler.LedgerExpenseRecordCreateFunc: method is nil but LedgersHandler.LedgerExpenseRecordCreate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Req    *server.LedgerExpenseRecordCreateReq
		Params server.LedgerExpenseRecordCreateParams
	}{
		Ctx:    ctx,
		Req:    req,
		Params: params,
	}
	mock.lockLedgerExpenseRecordCreate.Lock()
	mock.calls.LedgerExpenseRecordCreate = append(mock.calls.LedgerExpenseRecordCreate, callInfo)
	mock.lockLedgerExpenseRecordCreate.Unlock()
	return mock.LedgerExpenseRecordCreateFunc(ctx, req, params)
}

// LedgerExpenseRecordCreateCalls gets all the calls that were made to LedgerExpenseRecordCreate.
// Check the length with:
//
//	len(mockedLedgersHandler.LedgerExpenseRecordCreateCalls())
func (mock *LedgersHandler) LedgerExpenseRecordCreateCalls() []struct {
	Ctx    context.Context
	Req    *server.LedgerExpenseRecordCreateReq
	Params server.LedgerExpenseRecordCreateParams
} {
	var calls []struct {
		Ctx    context.Context
		Req    *server.LedgerExpenseRecordCreateReq
		Params server.LedgerExpenseRecordCreateParams
	}
	mock.lockLedgerExpenseRecordCreate.RLock()
	calls = mock.calls.LedgerExpenseRecordCreate
	mock.lockLedgerExpenseRecordCreate.RUnlock()
	return calls
}

// LedgerExpenseRecordDelete calls LedgerExpenseRecordDeleteFunc.
func (mock *LedgersHandler) LedgerExpenseRecordDelete(ctx context.Context, params server.LedgerExpenseRecordDeleteParams) error {
	if mock.LedgerExpenseRecordDeleteFunc == nil {
		panic("LedgersHandler.LedgerExpenseRecordDeleteFunc: method is nil but LedgersHandler.LedgerExpenseRecordDelete was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerExpenseRecordDeleteParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerExpenseRecordDelete.Lock()
	mock.calls.LedgerExpenseRecordDelete = append(mock.calls.LedgerExpenseRecordDelete, callInfo)
	mock.lockLedgerExpenseRecordDelete.Unlock()
	return mock.LedgerExpenseRecordDeleteFunc(ctx, params)
}

// LedgerExpenseRecordDeleteCalls gets all the calls that were made to LedgerExpenseRecordDelete.
// Check the length with:
//
//	len(mockedLedgersHandler.LedgerExpenseRecordDeleteCalls())
func (mock *LedgersHandler) LedgerExpenseRecordDeleteCalls() []struct {
	Ctx    context.Context
	Params server.LedgerExpenseRecordDeleteParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerExpenseRecordDeleteParams
	}
	mock.lockLedgerExpenseRecordDelete.RLock()
	calls = mock.calls.LedgerExpenseRecordDelete
	mock.lockLedgerExpenseRecordDelete.RUnlock()
	return calls
}

// LedgerList calls LedgerListFunc.
func (mock *LedgersHandler) LedgerList(ctx context.Context) (*server.LedgerListOK, error) {
	if mock.LedgerListFunc == nil {
		panic("LedgersHandler.LedgerListFunc: method is nil but LedgersHandler.LedgerList was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLedgerList.Lock()
	mock.calls.LedgerList = append(mock.calls.LedgerList, callInfo)
	mock.lockLedgerList.Unlock()
	return mock.LedgerListFunc(ctx)
}

// LedgerListCalls gets all the calls that were made to LedgerList.
// Check the length with:
//
//	len(mockedLedgersHandler.LedgerListCalls())
func (mock *LedgersHandler) LedgerListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLedgerList.RLock()
	calls = mock.calls.LedgerList
	mock.lockLedgerList.RUnlock()
	return calls
}

// LedgerMemberAdd calls LedgerMemberAddFunc.
func (mock *LedgersHandler) LedgerMemberAdd(ctx context.Context, req *server.LedgerMemberAddReq, params server.LedgerMemberAddParams) error {
	if mock.LedgerMemberAddFunc == nil {
		panic("LedgersHandler.LedgerMemberAddFunc: method is nil but LedgersHandler.LedgerMemberAdd was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Req    *server.LedgerMemberAddReq
		Params server.LedgerMemberAddParams
	}{
		Ctx:    ctx,
		Req:    req,
		Params: params,
	}
	mock.lockLedgerMemberAdd.Lock()
	mock.calls.LedgerMemberAdd = append(mock.calls.LedgerMemberAdd, callInfo)
	mock.lockLedgerMemberAdd.Unlock()
	return mock.LedgerMemberAddFunc(ctx, req, params)
}

// LedgerMemberAddCalls gets all the calls that were made to LedgerMemberAdd.
// Check the length with:
//
//	len(mockedLedgersHandler.LedgerMemberAddCalls())
func (mock *LedgersHandler) LedgerMemberAddCalls() []struct {
	Ctx    context.Context
	Req    *server.LedgerMemberAddReq
	Params server.LedgerMemberAddParams
} {
	var calls []struct {
		Ctx    context.Context
		Req    *server.LedgerMemberAddReq
		Params server.LedgerMemberAddParams
	}
	mock.lockLedgerMemberAdd.RLock()
	calls = mock.calls.LedgerMemberAdd
	mock.lockLedgerMemberAdd.RUnlock()
	return calls
}

// LedgerMemberList calls LedgerMemberListFunc.
func (mock *LedgersHandler) LedgerMemberList(ctx context.Context, params server.LedgerMemberListParams) (*server.LedgerMemberListOK, error) {
	if mock.LedgerMemberListFunc == nil {
		panic("LedgersHandler.LedgerMemberListFunc: method is nil but LedgersHandler.LedgerMemberList was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params server.LedgerMemberListParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockLedgerMemberList.Lock()
	mock.calls.LedgerMemberList = append(mock.calls.LedgerMemberList, callInfo)
	mock.lockLedgerMemberList.Unlock()
	return mock.LedgerMemberListFunc(ctx, params)
}

// LedgerMemberListCalls gets all the calls that were made to LedgerMemberList.
// Check the length with:
//
//	len(mockedLedgersHandler.LedgerMemberListCalls())
func (mock *LedgersHandler) LedgerMemberListCalls() []struct {
	Ctx    context.Context
	Params server.LedgerMemberListParams
} {
	var calls []struct {
		Ctx    context.Context
		Params server.LedgerMemberListParams
	}
	mock.lockLedgerMemberList.RLock()
	calls = mock.calls.LedgerMemberList
	mock.lockLedgerMemberList.RUnlock()
	return calls
}

// Ensure that UsersHandler does implement server.UsersHandler.
// If this is not the case, regenerate this file with mockery.
var _ server.UsersHandler = &UsersHandler{}

// UsersHandler is a mock implementation of server.UsersHandler.
//
//	func TestSomethingThatUsesUsersHandler(t *testing.T) {
//
//		// make and configure a mocked server.UsersHandler
//		mockedUsersHandler := &UsersHandler{
//			AuthenticationLoginFunc: func(ctx context.Context, req *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error) {
//				panic("mock out the AuthenticationLogin method")
//			},
//			AuthenticationWhoAmIFunc: func(ctx context.Context) (*server.AuthenticationWhoAmIOK, error) {
//				panic("mock out the AuthenticationWhoAmI method")
//			},
//			UserRegisterFunc: func(ctx context.Context, req *server.UserRegisterReq) (*server.UserRegisterOK, error) {
//				panic("mock out the UserRegister method")
//			},
//		}
//
//		// use mockedUsersHandler in code that requires server.UsersHandler
//		// and then make assertions.
//
//	}
type UsersHandler struct {
	// AuthenticationLoginFunc mocks the AuthenticationLogin method.
	AuthenticationLoginFunc func(ctx context.Context, req *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error)

	// AuthenticationWhoAmIFunc mocks the AuthenticationWhoAmI method.
	AuthenticationWhoAmIFunc func(ctx context.Context) (*server.AuthenticationWhoAmIOK, error)

	// UserRegisterFunc mocks the UserRegister method.
	UserRegisterFunc func(ctx context.Context, req *server.UserRegisterReq) (*server.UserRegisterOK, error)

	// calls tracks calls to the methods.
	calls struct {
		// AuthenticationLogin holds details about calls to the AuthenticationLogin method.
		AuthenticationLogin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.AuthenticationLoginReq
		}
		// AuthenticationWhoAmI holds details about calls to the AuthenticationWhoAmI method.
		AuthenticationWhoAmI []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UserRegister holds details about calls to the UserRegister method.
		UserRegister []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *server.UserRegisterReq
		}
	}
	lockAuthenticationLogin  sync.RWMutex
	lockAuthenticationWhoAmI sync.RWMutex
	lockUserRegister         sync.RWMutex
}

// AuthenticationLogin calls AuthenticationLoginFunc.
func (mock *UsersHandler) AuthenticationLogin(ctx context.Context, req *server.AuthenticationLoginReq) (*server.AuthenticationLoginOK, error) {
	if mock.AuthenticationLoginFunc == nil {
		panic("UsersHandler.AuthenticationLoginFunc: method is nil but UsersHandler.AuthenticationLogin was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *server.AuthenticationLoginReq
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockAuthenticationLogin.Lock()
	mock.calls.AuthenticationLogin = append(mock.calls.AuthenticationLogin, callInfo)
	mock.lockAuthenticationLogin.Unlock()
	return mock.AuthenticationLoginFunc(ctx, req)
}

// AuthenticationLoginCalls gets all the calls that were made to AuthenticationLogin.
// Check the length with:
//
//	len(mockedUsersHandler.AuthenticationLoginCalls())
func (mock *UsersHandler) AuthenticationLoginCalls() []struct {
	Ctx context.Context
	Req *server.AuthenticationLoginReq
} {
	var calls []struct {
		Ctx context.Context
		Req *server.AuthenticationLoginReq
	}
	mock.lockAuthenticationLogin.RLock()
	calls = mock.calls.AuthenticationLogin
	mock.lockAuthenticationLogin.RUnlock()
	return calls
}

// AuthenticationWhoAmI calls AuthenticationWhoAmIFunc.
func (mock *UsersHandler) AuthenticationWhoAmI(ctx context.Context) (*server.AuthenticationWhoAmIOK, error) {
	if mock.AuthenticationWhoAmIFunc == nil {
		panic("UsersHandler.AuthenticationWhoAmIFunc: method is nil but UsersHandler.AuthenticationWhoAmI was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAuthenticationWhoAmI.Lock()
	mock.calls.AuthenticationWhoAmI = append(mock.calls.AuthenticationWhoAmI, callInfo)
	mock.lockAuthenticationWhoAmI.Unlock()
	return mock.AuthenticationWhoAmIFunc(ctx)
}

// AuthenticationWhoAmICalls gets all the calls that were made to AuthenticationWhoAmI.
// Check the length with:
//
//	len(mockedUsersHandler.AuthenticationWhoAmICalls())
func (mock *UsersHandler) AuthenticationWhoAmICalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAuthenticationWhoAmI.RLock()
	calls = mock.calls.AuthenticationWhoAmI
	mock.lockAuthenticationWhoAmI.RUnlock()
	return calls
}

// UserRegister calls UserRegisterFunc.
func (mock *UsersHandler) UserRegister(ctx context.Context, req *server.UserRegisterReq) (*server.UserRegisterOK, error) {
	if mock.UserRegisterFunc == nil {
		panic("UsersHandler.UserRegisterFunc: method is nil but UsersHandler.UserRegister was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *server.UserRegisterReq
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockUserRegister.Lock()
	mock.calls.UserRegister = append(mock.calls.UserRegister, callInfo)
	mock.lockUserRegister.Unlock()
	return mock.UserRegisterFunc(ctx, req)
}

// UserRegisterCalls gets all the calls that were made to UserRegister.
// Check the length with:
//
//	len(mockedUsersHandler.UserRegisterCalls())
func (mock *UsersHandler) UserRegisterCalls() []struct {
	Ctx context.Context
	Req *server.UserRegisterReq
} {
	var calls []struct {
		Ctx context.Context
		Req *server.UserRegisterReq
	}
	mock.lockUserRegister.RLock()
	calls = mock.calls.UserRegister
	mock.lockUserRegister.RUnlock()
	return calls
}
