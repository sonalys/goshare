// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package usercontrollermock

import (
	"context"
	"sync"

	"github.com/sonalys/goshare/internal/application/controllers/usercontroller"
	"github.com/sonalys/goshare/internal/domain"
)

// Ensure that Controller does implement usercontroller.Controller.
// If this is not the case, regenerate this file with mockery.
var _ usercontroller.Controller = &Controller{}

// Controller is a mock implementation of usercontroller.Controller.
//
//	func TestSomethingThatUsesController(t *testing.T) {
//
//		// make and configure a mocked usercontroller.Controller
//		mockedController := &Controller{
//			ExpensesFunc: func() usercontroller.ExpenseController {
//				panic("mock out the Expenses method")
//			},
//			LedgersFunc: func() usercontroller.LedgerController {
//				panic("mock out the Ledgers method")
//			},
//			RecordsFunc: func() usercontroller.RecordsController {
//				panic("mock out the Records method")
//			},
//		}
//
//		// use mockedController in code that requires usercontroller.Controller
//		// and then make assertions.
//
//	}
type Controller struct {
	// ExpensesFunc mocks the Expenses method.
	ExpensesFunc func() usercontroller.ExpenseController

	// LedgersFunc mocks the Ledgers method.
	LedgersFunc func() usercontroller.LedgerController

	// RecordsFunc mocks the Records method.
	RecordsFunc func() usercontroller.RecordsController

	// calls tracks calls to the methods.
	calls struct {
		// Expenses holds details about calls to the Expenses method.
		Expenses []struct {
		}
		// Ledgers holds details about calls to the Ledgers method.
		Ledgers []struct {
		}
		// Records holds details about calls to the Records method.
		Records []struct {
		}
	}
	lockExpenses sync.RWMutex
	lockLedgers  sync.RWMutex
	lockRecords  sync.RWMutex
}

// Expenses calls ExpensesFunc.
func (mock *Controller) Expenses() usercontroller.ExpenseController {
	if mock.ExpensesFunc == nil {
		panic("Controller.ExpensesFunc: method is nil but Controller.Expenses was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExpenses.Lock()
	mock.calls.Expenses = append(mock.calls.Expenses, callInfo)
	mock.lockExpenses.Unlock()
	return mock.ExpensesFunc()
}

// ExpensesCalls gets all the calls that were made to Expenses.
// Check the length with:
//
//	len(mockedController.ExpensesCalls())
func (mock *Controller) ExpensesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExpenses.RLock()
	calls = mock.calls.Expenses
	mock.lockExpenses.RUnlock()
	return calls
}

// Ledgers calls LedgersFunc.
func (mock *Controller) Ledgers() usercontroller.LedgerController {
	if mock.LedgersFunc == nil {
		panic("Controller.LedgersFunc: method is nil but Controller.Ledgers was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLedgers.Lock()
	mock.calls.Ledgers = append(mock.calls.Ledgers, callInfo)
	mock.lockLedgers.Unlock()
	return mock.LedgersFunc()
}

// LedgersCalls gets all the calls that were made to Ledgers.
// Check the length with:
//
//	len(mockedController.LedgersCalls())
func (mock *Controller) LedgersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLedgers.RLock()
	calls = mock.calls.Ledgers
	mock.lockLedgers.RUnlock()
	return calls
}

// Records calls RecordsFunc.
func (mock *Controller) Records() usercontroller.RecordsController {
	if mock.RecordsFunc == nil {
		panic("Controller.RecordsFunc: method is nil but Controller.Records was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRecords.Lock()
	mock.calls.Records = append(mock.calls.Records, callInfo)
	mock.lockRecords.Unlock()
	return mock.RecordsFunc()
}

// RecordsCalls gets all the calls that were made to Records.
// Check the length with:
//
//	len(mockedController.RecordsCalls())
func (mock *Controller) RecordsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRecords.RLock()
	calls = mock.calls.Records
	mock.lockRecords.RUnlock()
	return calls
}

// Ensure that ExpenseController does implement usercontroller.ExpenseController.
// If this is not the case, regenerate this file with mockery.
var _ usercontroller.ExpenseController = &ExpenseController{}

// ExpenseController is a mock implementation of usercontroller.ExpenseController.
//
//	func TestSomethingThatUsesExpenseController(t *testing.T) {
//
//		// make and configure a mocked usercontroller.ExpenseController
//		mockedExpenseController := &ExpenseController{
//			CreateFunc: func(ctx context.Context, req usercontroller.CreateExpenseRequest) (*usercontroller.CreateExpenseResponse, error) {
//				panic("mock out the Create method")
//			},
//			GetFunc: func(ctx context.Context, req usercontroller.GetExpenseRequest) (*domain.Expense, error) {
//				panic("mock out the Get method")
//			},
//			ListFunc: func(ctx context.Context, req usercontroller.ListExpensesRequest) (*usercontroller.ListExpensesResponse, error) {
//				panic("mock out the List method")
//			},
//		}
//
//		// use mockedExpenseController in code that requires usercontroller.ExpenseController
//		// and then make assertions.
//
//	}
type ExpenseController struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, req usercontroller.CreateExpenseRequest) (*usercontroller.CreateExpenseResponse, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, req usercontroller.GetExpenseRequest) (*domain.Expense, error)

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, req usercontroller.ListExpensesRequest) (*usercontroller.ListExpensesResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req usercontroller.CreateExpenseRequest
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req usercontroller.GetExpenseRequest
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req usercontroller.ListExpensesRequest
		}
	}
	lockCreate sync.RWMutex
	lockGet    sync.RWMutex
	lockList   sync.RWMutex
}

// Create calls CreateFunc.
func (mock *ExpenseController) Create(ctx context.Context, req usercontroller.CreateExpenseRequest) (*usercontroller.CreateExpenseResponse, error) {
	if mock.CreateFunc == nil {
		panic("ExpenseController.CreateFunc: method is nil but ExpenseController.Create was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req usercontroller.CreateExpenseRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, req)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedExpenseController.CreateCalls())
func (mock *ExpenseController) CreateCalls() []struct {
	Ctx context.Context
	Req usercontroller.CreateExpenseRequest
} {
	var calls []struct {
		Ctx context.Context
		Req usercontroller.CreateExpenseRequest
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *ExpenseController) Get(ctx context.Context, req usercontroller.GetExpenseRequest) (*domain.Expense, error) {
	if mock.GetFunc == nil {
		panic("ExpenseController.GetFunc: method is nil but ExpenseController.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req usercontroller.GetExpenseRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, req)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedExpenseController.GetCalls())
func (mock *ExpenseController) GetCalls() []struct {
	Ctx context.Context
	Req usercontroller.GetExpenseRequest
} {
	var calls []struct {
		Ctx context.Context
		Req usercontroller.GetExpenseRequest
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *ExpenseController) List(ctx context.Context, req usercontroller.ListExpensesRequest) (*usercontroller.ListExpensesResponse, error) {
	if mock.ListFunc == nil {
		panic("ExpenseController.ListFunc: method is nil but ExpenseController.List was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req usercontroller.ListExpensesRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(ctx, req)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedExpenseController.ListCalls())
func (mock *ExpenseController) ListCalls() []struct {
	Ctx context.Context
	Req usercontroller.ListExpensesRequest
} {
	var calls []struct {
		Ctx context.Context
		Req usercontroller.ListExpensesRequest
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// Ensure that LedgerController does implement usercontroller.LedgerController.
// If this is not the case, regenerate this file with mockery.
var _ usercontroller.LedgerController = &LedgerController{}

// LedgerController is a mock implementation of usercontroller.LedgerController.
//
//	func TestSomethingThatUsesLedgerController(t *testing.T) {
//
//		// make and configure a mocked usercontroller.LedgerController
//		mockedLedgerController := &LedgerController{
//			CreateFunc: func(ctx context.Context, req usercontroller.CreateLedgerRequest) (*usercontroller.CreateLedgerResponse, error) {
//				panic("mock out the Create method")
//			},
//			GetFunc: func(ctx context.Context, req usercontroller.GetLedgerRequest) (*domain.Ledger, error) {
//				panic("mock out the Get method")
//			},
//			ListByUserFunc: func(ctx context.Context, actorID domain.ID) ([]domain.Ledger, error) {
//				panic("mock out the ListByUser method")
//			},
//			MembersAddFunc: func(ctx context.Context, req usercontroller.AddMembersRequest) error {
//				panic("mock out the MembersAdd method")
//			},
//		}
//
//		// use mockedLedgerController in code that requires usercontroller.LedgerController
//		// and then make assertions.
//
//	}
type LedgerController struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, req usercontroller.CreateLedgerRequest) (*usercontroller.CreateLedgerResponse, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, req usercontroller.GetLedgerRequest) (*domain.Ledger, error)

	// ListByUserFunc mocks the ListByUser method.
	ListByUserFunc func(ctx context.Context, actorID domain.ID) ([]domain.Ledger, error)

	// MembersAddFunc mocks the MembersAdd method.
	MembersAddFunc func(ctx context.Context, req usercontroller.AddMembersRequest) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req usercontroller.CreateLedgerRequest
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req usercontroller.GetLedgerRequest
		}
		// ListByUser holds details about calls to the ListByUser method.
		ListByUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ActorID is the actorID argument value.
			ActorID domain.ID
		}
		// MembersAdd holds details about calls to the MembersAdd method.
		MembersAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req usercontroller.AddMembersRequest
		}
	}
	lockCreate     sync.RWMutex
	lockGet        sync.RWMutex
	lockListByUser sync.RWMutex
	lockMembersAdd sync.RWMutex
}

// Create calls CreateFunc.
func (mock *LedgerController) Create(ctx context.Context, req usercontroller.CreateLedgerRequest) (*usercontroller.CreateLedgerResponse, error) {
	if mock.CreateFunc == nil {
		panic("LedgerController.CreateFunc: method is nil but LedgerController.Create was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req usercontroller.CreateLedgerRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, req)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedLedgerController.CreateCalls())
func (mock *LedgerController) CreateCalls() []struct {
	Ctx context.Context
	Req usercontroller.CreateLedgerRequest
} {
	var calls []struct {
		Ctx context.Context
		Req usercontroller.CreateLedgerRequest
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *LedgerController) Get(ctx context.Context, req usercontroller.GetLedgerRequest) (*domain.Ledger, error) {
	if mock.GetFunc == nil {
		panic("LedgerController.GetFunc: method is nil but LedgerController.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req usercontroller.GetLedgerRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, req)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedLedgerController.GetCalls())
func (mock *LedgerController) GetCalls() []struct {
	Ctx context.Context
	Req usercontroller.GetLedgerRequest
} {
	var calls []struct {
		Ctx context.Context
		Req usercontroller.GetLedgerRequest
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ListByUser calls ListByUserFunc.
func (mock *LedgerController) ListByUser(ctx context.Context, actorID domain.ID) ([]domain.Ledger, error) {
	if mock.ListByUserFunc == nil {
		panic("LedgerController.ListByUserFunc: method is nil but LedgerController.ListByUser was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ActorID domain.ID
	}{
		Ctx:     ctx,
		ActorID: actorID,
	}
	mock.lockListByUser.Lock()
	mock.calls.ListByUser = append(mock.calls.ListByUser, callInfo)
	mock.lockListByUser.Unlock()
	return mock.ListByUserFunc(ctx, actorID)
}

// ListByUserCalls gets all the calls that were made to ListByUser.
// Check the length with:
//
//	len(mockedLedgerController.ListByUserCalls())
func (mock *LedgerController) ListByUserCalls() []struct {
	Ctx     context.Context
	ActorID domain.ID
} {
	var calls []struct {
		Ctx     context.Context
		ActorID domain.ID
	}
	mock.lockListByUser.RLock()
	calls = mock.calls.ListByUser
	mock.lockListByUser.RUnlock()
	return calls
}

// MembersAdd calls MembersAddFunc.
func (mock *LedgerController) MembersAdd(ctx context.Context, req usercontroller.AddMembersRequest) error {
	if mock.MembersAddFunc == nil {
		panic("LedgerController.MembersAddFunc: method is nil but LedgerController.MembersAdd was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req usercontroller.AddMembersRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockMembersAdd.Lock()
	mock.calls.MembersAdd = append(mock.calls.MembersAdd, callInfo)
	mock.lockMembersAdd.Unlock()
	return mock.MembersAddFunc(ctx, req)
}

// MembersAddCalls gets all the calls that were made to MembersAdd.
// Check the length with:
//
//	len(mockedLedgerController.MembersAddCalls())
func (mock *LedgerController) MembersAddCalls() []struct {
	Ctx context.Context
	Req usercontroller.AddMembersRequest
} {
	var calls []struct {
		Ctx context.Context
		Req usercontroller.AddMembersRequest
	}
	mock.lockMembersAdd.RLock()
	calls = mock.calls.MembersAdd
	mock.lockMembersAdd.RUnlock()
	return calls
}

// Ensure that RecordsController does implement usercontroller.RecordsController.
// If this is not the case, regenerate this file with mockery.
var _ usercontroller.RecordsController = &RecordsController{}

// RecordsController is a mock implementation of usercontroller.RecordsController.
//
//	func TestSomethingThatUsesRecordsController(t *testing.T) {
//
//		// make and configure a mocked usercontroller.RecordsController
//		mockedRecordsController := &RecordsController{
//			CreateFunc: func(ctx context.Context, req usercontroller.CreateExpenseRecordRequest) (*domain.Expense, error) {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, req usercontroller.DeleteExpenseRecordRequest) error {
//				panic("mock out the Delete method")
//			},
//		}
//
//		// use mockedRecordsController in code that requires usercontroller.RecordsController
//		// and then make assertions.
//
//	}
type RecordsController struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, req usercontroller.CreateExpenseRecordRequest) (*domain.Expense, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, req usercontroller.DeleteExpenseRecordRequest) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req usercontroller.CreateExpenseRecordRequest
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req usercontroller.DeleteExpenseRecordRequest
		}
	}
	lockCreate sync.RWMutex
	lockDelete sync.RWMutex
}

// Create calls CreateFunc.
func (mock *RecordsController) Create(ctx context.Context, req usercontroller.CreateExpenseRecordRequest) (*domain.Expense, error) {
	if mock.CreateFunc == nil {
		panic("RecordsController.CreateFunc: method is nil but RecordsController.Create was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req usercontroller.CreateExpenseRecordRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, req)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedRecordsController.CreateCalls())
func (mock *RecordsController) CreateCalls() []struct {
	Ctx context.Context
	Req usercontroller.CreateExpenseRecordRequest
} {
	var calls []struct {
		Ctx context.Context
		Req usercontroller.CreateExpenseRecordRequest
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *RecordsController) Delete(ctx context.Context, req usercontroller.DeleteExpenseRecordRequest) error {
	if mock.DeleteFunc == nil {
		panic("RecordsController.DeleteFunc: method is nil but RecordsController.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req usercontroller.DeleteExpenseRecordRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, req)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedRecordsController.DeleteCalls())
func (mock *RecordsController) DeleteCalls() []struct {
	Ctx context.Context
	Req usercontroller.DeleteExpenseRecordRequest
} {
	var calls []struct {
		Ctx context.Context
		Req usercontroller.DeleteExpenseRecordRequest
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}
