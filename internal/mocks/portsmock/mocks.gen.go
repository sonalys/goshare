// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package portsmock

import (
	"context"
	"sync"
	"time"

	"github.com/sonalys/goshare/internal/domain"
	"github.com/sonalys/goshare/internal/ports"
	v1 "github.com/sonalys/goshare/pkg/v1"
)

// Ensure that ExpenseQueries does implement ports.ExpenseQueries.
// If this is not the case, regenerate this file with mockery.
var _ ports.ExpenseQueries = &ExpenseQueries{}

// ExpenseQueries is a mock implementation of ports.ExpenseQueries.
//
//	func TestSomethingThatUsesExpenseQueries(t *testing.T) {
//
//		// make and configure a mocked ports.ExpenseQueries
//		mockedExpenseQueries := &ExpenseQueries{
//			GetFunc: func(ctx context.Context, id domain.ID) (*domain.Expense, error) {
//				panic("mock out the Get method")
//			},
//			ListByLedgerFunc: func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
//				panic("mock out the ListByLedger method")
//			},
//		}
//
//		// use mockedExpenseQueries in code that requires ports.ExpenseQueries
//		// and then make assertions.
//
//	}
type ExpenseQueries struct {
	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id domain.ID) (*domain.Expense, error)

	// ListByLedgerFunc mocks the ListByLedger method.
	ListByLedgerFunc func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// ListByLedger holds details about calls to the ListByLedger method.
		ListByLedger []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Cursor is the cursor argument value.
			Cursor time.Time
			// Limit is the limit argument value.
			Limit int32
		}
	}
	lockGet          sync.RWMutex
	lockListByLedger sync.RWMutex
}

// Get calls GetFunc.
func (mock *ExpenseQueries) Get(ctx context.Context, id domain.ID) (*domain.Expense, error) {
	if mock.GetFunc == nil {
		panic("ExpenseQueries.GetFunc: method is nil but ExpenseQueries.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedExpenseQueries.GetCalls())
func (mock *ExpenseQueries) GetCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ListByLedger calls ListByLedgerFunc.
func (mock *ExpenseQueries) ListByLedger(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
	if mock.ListByLedgerFunc == nil {
		panic("ExpenseQueries.ListByLedgerFunc: method is nil but ExpenseQueries.ListByLedger was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Cursor:   cursor,
		Limit:    limit,
	}
	mock.lockListByLedger.Lock()
	mock.calls.ListByLedger = append(mock.calls.ListByLedger, callInfo)
	mock.lockListByLedger.Unlock()
	return mock.ListByLedgerFunc(ctx, ledgerID, cursor, limit)
}

// ListByLedgerCalls gets all the calls that were made to ListByLedger.
// Check the length with:
//
//	len(mockedExpenseQueries.ListByLedgerCalls())
func (mock *ExpenseQueries) ListByLedgerCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Cursor   time.Time
	Limit    int32
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}
	mock.lockListByLedger.RLock()
	calls = mock.calls.ListByLedger
	mock.lockListByLedger.RUnlock()
	return calls
}

// Ensure that ExpenseCommands does implement ports.ExpenseCommands.
// If this is not the case, regenerate this file with mockery.
var _ ports.ExpenseCommands = &ExpenseCommands{}

// ExpenseCommands is a mock implementation of ports.ExpenseCommands.
//
//	func TestSomethingThatUsesExpenseCommands(t *testing.T) {
//
//		// make and configure a mocked ports.ExpenseCommands
//		mockedExpenseCommands := &ExpenseCommands{
//			CreateFunc: func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
//				panic("mock out the Create method")
//			},
//			UpdateFunc: func(ctx context.Context, expense *domain.Expense) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedExpenseCommands in code that requires ports.ExpenseCommands
//		// and then make assertions.
//
//	}
type ExpenseCommands struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, expense *domain.Expense) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
	}
	lockCreate sync.RWMutex
	lockUpdate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *ExpenseCommands) Create(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
	if mock.CreateFunc == nil {
		panic("ExpenseCommands.CreateFunc: method is nil but ExpenseCommands.Create was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Expense:  expense,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledgerID, expense)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedExpenseCommands.CreateCalls())
func (mock *ExpenseCommands) CreateCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Expense  *domain.Expense
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ExpenseCommands) Update(ctx context.Context, expense *domain.Expense) error {
	if mock.UpdateFunc == nil {
		panic("ExpenseCommands.UpdateFunc: method is nil but ExpenseCommands.Update was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Expense *domain.Expense
	}{
		Ctx:     ctx,
		Expense: expense,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, expense)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedExpenseCommands.UpdateCalls())
func (mock *ExpenseCommands) UpdateCalls() []struct {
	Ctx     context.Context
	Expense *domain.Expense
} {
	var calls []struct {
		Ctx     context.Context
		Expense *domain.Expense
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that ExpenseRepository does implement ports.ExpenseRepository.
// If this is not the case, regenerate this file with mockery.
var _ ports.ExpenseRepository = &ExpenseRepository{}

// ExpenseRepository is a mock implementation of ports.ExpenseRepository.
//
//	func TestSomethingThatUsesExpenseRepository(t *testing.T) {
//
//		// make and configure a mocked ports.ExpenseRepository
//		mockedExpenseRepository := &ExpenseRepository{
//			CreateFunc: func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
//				panic("mock out the Create method")
//			},
//			GetFunc: func(ctx context.Context, id domain.ID) (*domain.Expense, error) {
//				panic("mock out the Get method")
//			},
//			ListByLedgerFunc: func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
//				panic("mock out the ListByLedger method")
//			},
//			UpdateFunc: func(ctx context.Context, expense *domain.Expense) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedExpenseRepository in code that requires ports.ExpenseRepository
//		// and then make assertions.
//
//	}
type ExpenseRepository struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id domain.ID) (*domain.Expense, error)

	// ListByLedgerFunc mocks the ListByLedger method.
	ListByLedgerFunc func(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, expense *domain.Expense) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// ListByLedger holds details about calls to the ListByLedger method.
		ListByLedger []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LedgerID is the ledgerID argument value.
			LedgerID domain.ID
			// Cursor is the cursor argument value.
			Cursor time.Time
			// Limit is the limit argument value.
			Limit int32
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Expense is the expense argument value.
			Expense *domain.Expense
		}
	}
	lockCreate       sync.RWMutex
	lockGet          sync.RWMutex
	lockListByLedger sync.RWMutex
	lockUpdate       sync.RWMutex
}

// Create calls CreateFunc.
func (mock *ExpenseRepository) Create(ctx context.Context, ledgerID domain.ID, expense *domain.Expense) error {
	if mock.CreateFunc == nil {
		panic("ExpenseRepository.CreateFunc: method is nil but ExpenseRepository.Create was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Expense:  expense,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledgerID, expense)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedExpenseRepository.CreateCalls())
func (mock *ExpenseRepository) CreateCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Expense  *domain.Expense
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Expense  *domain.Expense
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *ExpenseRepository) Get(ctx context.Context, id domain.ID) (*domain.Expense, error) {
	if mock.GetFunc == nil {
		panic("ExpenseRepository.GetFunc: method is nil but ExpenseRepository.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedExpenseRepository.GetCalls())
func (mock *ExpenseRepository) GetCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ListByLedger calls ListByLedgerFunc.
func (mock *ExpenseRepository) ListByLedger(ctx context.Context, ledgerID domain.ID, cursor time.Time, limit int32) ([]v1.LedgerExpenseSummary, error) {
	if mock.ListByLedgerFunc == nil {
		panic("ExpenseRepository.ListByLedgerFunc: method is nil but ExpenseRepository.ListByLedger was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}{
		Ctx:      ctx,
		LedgerID: ledgerID,
		Cursor:   cursor,
		Limit:    limit,
	}
	mock.lockListByLedger.Lock()
	mock.calls.ListByLedger = append(mock.calls.ListByLedger, callInfo)
	mock.lockListByLedger.Unlock()
	return mock.ListByLedgerFunc(ctx, ledgerID, cursor, limit)
}

// ListByLedgerCalls gets all the calls that were made to ListByLedger.
// Check the length with:
//
//	len(mockedExpenseRepository.ListByLedgerCalls())
func (mock *ExpenseRepository) ListByLedgerCalls() []struct {
	Ctx      context.Context
	LedgerID domain.ID
	Cursor   time.Time
	Limit    int32
} {
	var calls []struct {
		Ctx      context.Context
		LedgerID domain.ID
		Cursor   time.Time
		Limit    int32
	}
	mock.lockListByLedger.RLock()
	calls = mock.calls.ListByLedger
	mock.lockListByLedger.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ExpenseRepository) Update(ctx context.Context, expense *domain.Expense) error {
	if mock.UpdateFunc == nil {
		panic("ExpenseRepository.UpdateFunc: method is nil but ExpenseRepository.Update was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Expense *domain.Expense
	}{
		Ctx:     ctx,
		Expense: expense,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, expense)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedExpenseRepository.UpdateCalls())
func (mock *ExpenseRepository) UpdateCalls() []struct {
	Ctx     context.Context
	Expense *domain.Expense
} {
	var calls []struct {
		Ctx     context.Context
		Expense *domain.Expense
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that LedgerQueries does implement ports.LedgerQueries.
// If this is not the case, regenerate this file with mockery.
var _ ports.LedgerQueries = &LedgerQueries{}

// LedgerQueries is a mock implementation of ports.LedgerQueries.
//
//	func TestSomethingThatUsesLedgerQueries(t *testing.T) {
//
//		// make and configure a mocked ports.LedgerQueries
//		mockedLedgerQueries := &LedgerQueries{
//			GetFunc: func(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
//				panic("mock out the Get method")
//			},
//			ListByUserFunc: func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
//				panic("mock out the ListByUser method")
//			},
//		}
//
//		// use mockedLedgerQueries in code that requires ports.LedgerQueries
//		// and then make assertions.
//
//	}
type LedgerQueries struct {
	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id domain.ID) (*domain.Ledger, error)

	// ListByUserFunc mocks the ListByUser method.
	ListByUserFunc func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// ListByUser holds details about calls to the ListByUser method.
		ListByUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Identity is the identity argument value.
			Identity domain.ID
		}
	}
	lockGet        sync.RWMutex
	lockListByUser sync.RWMutex
}

// Get calls GetFunc.
func (mock *LedgerQueries) Get(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
	if mock.GetFunc == nil {
		panic("LedgerQueries.GetFunc: method is nil but LedgerQueries.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedLedgerQueries.GetCalls())
func (mock *LedgerQueries) GetCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ListByUser calls ListByUserFunc.
func (mock *LedgerQueries) ListByUser(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
	if mock.ListByUserFunc == nil {
		panic("LedgerQueries.ListByUserFunc: method is nil but LedgerQueries.ListByUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Identity domain.ID
	}{
		Ctx:      ctx,
		Identity: identity,
	}
	mock.lockListByUser.Lock()
	mock.calls.ListByUser = append(mock.calls.ListByUser, callInfo)
	mock.lockListByUser.Unlock()
	return mock.ListByUserFunc(ctx, identity)
}

// ListByUserCalls gets all the calls that were made to ListByUser.
// Check the length with:
//
//	len(mockedLedgerQueries.ListByUserCalls())
func (mock *LedgerQueries) ListByUserCalls() []struct {
	Ctx      context.Context
	Identity domain.ID
} {
	var calls []struct {
		Ctx      context.Context
		Identity domain.ID
	}
	mock.lockListByUser.RLock()
	calls = mock.calls.ListByUser
	mock.lockListByUser.RUnlock()
	return calls
}

// Ensure that LedgerCommands does implement ports.LedgerCommands.
// If this is not the case, regenerate this file with mockery.
var _ ports.LedgerCommands = &LedgerCommands{}

// LedgerCommands is a mock implementation of ports.LedgerCommands.
//
//	func TestSomethingThatUsesLedgerCommands(t *testing.T) {
//
//		// make and configure a mocked ports.LedgerCommands
//		mockedLedgerCommands := &LedgerCommands{
//			CreateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Create method")
//			},
//			UpdateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedLedgerCommands in code that requires ports.LedgerCommands
//		// and then make assertions.
//
//	}
type LedgerCommands struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
	}
	lockCreate sync.RWMutex
	lockUpdate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *LedgerCommands) Create(ctx context.Context, ledger *domain.Ledger) error {
	if mock.CreateFunc == nil {
		panic("LedgerCommands.CreateFunc: method is nil but LedgerCommands.Create was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledger)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedLedgerCommands.CreateCalls())
func (mock *LedgerCommands) CreateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *LedgerCommands) Update(ctx context.Context, ledger *domain.Ledger) error {
	if mock.UpdateFunc == nil {
		panic("LedgerCommands.UpdateFunc: method is nil but LedgerCommands.Update was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, ledger)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedLedgerCommands.UpdateCalls())
func (mock *LedgerCommands) UpdateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that LedgerRepository does implement ports.LedgerRepository.
// If this is not the case, regenerate this file with mockery.
var _ ports.LedgerRepository = &LedgerRepository{}

// LedgerRepository is a mock implementation of ports.LedgerRepository.
//
//	func TestSomethingThatUsesLedgerRepository(t *testing.T) {
//
//		// make and configure a mocked ports.LedgerRepository
//		mockedLedgerRepository := &LedgerRepository{
//			CreateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Create method")
//			},
//			GetFunc: func(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
//				panic("mock out the Get method")
//			},
//			ListByUserFunc: func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
//				panic("mock out the ListByUser method")
//			},
//			UpdateFunc: func(ctx context.Context, ledger *domain.Ledger) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedLedgerRepository in code that requires ports.LedgerRepository
//		// and then make assertions.
//
//	}
type LedgerRepository struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id domain.ID) (*domain.Ledger, error)

	// ListByUserFunc mocks the ListByUser method.
	ListByUserFunc func(ctx context.Context, identity domain.ID) ([]domain.Ledger, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, ledger *domain.Ledger) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// ListByUser holds details about calls to the ListByUser method.
		ListByUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Identity is the identity argument value.
			Identity domain.ID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ledger is the ledger argument value.
			Ledger *domain.Ledger
		}
	}
	lockCreate     sync.RWMutex
	lockGet        sync.RWMutex
	lockListByUser sync.RWMutex
	lockUpdate     sync.RWMutex
}

// Create calls CreateFunc.
func (mock *LedgerRepository) Create(ctx context.Context, ledger *domain.Ledger) error {
	if mock.CreateFunc == nil {
		panic("LedgerRepository.CreateFunc: method is nil but LedgerRepository.Create was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, ledger)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedLedgerRepository.CreateCalls())
func (mock *LedgerRepository) CreateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *LedgerRepository) Get(ctx context.Context, id domain.ID) (*domain.Ledger, error) {
	if mock.GetFunc == nil {
		panic("LedgerRepository.GetFunc: method is nil but LedgerRepository.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedLedgerRepository.GetCalls())
func (mock *LedgerRepository) GetCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ListByUser calls ListByUserFunc.
func (mock *LedgerRepository) ListByUser(ctx context.Context, identity domain.ID) ([]domain.Ledger, error) {
	if mock.ListByUserFunc == nil {
		panic("LedgerRepository.ListByUserFunc: method is nil but LedgerRepository.ListByUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Identity domain.ID
	}{
		Ctx:      ctx,
		Identity: identity,
	}
	mock.lockListByUser.Lock()
	mock.calls.ListByUser = append(mock.calls.ListByUser, callInfo)
	mock.lockListByUser.Unlock()
	return mock.ListByUserFunc(ctx, identity)
}

// ListByUserCalls gets all the calls that were made to ListByUser.
// Check the length with:
//
//	len(mockedLedgerRepository.ListByUserCalls())
func (mock *LedgerRepository) ListByUserCalls() []struct {
	Ctx      context.Context
	Identity domain.ID
} {
	var calls []struct {
		Ctx      context.Context
		Identity domain.ID
	}
	mock.lockListByUser.RLock()
	calls = mock.calls.ListByUser
	mock.lockListByUser.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *LedgerRepository) Update(ctx context.Context, ledger *domain.Ledger) error {
	if mock.UpdateFunc == nil {
		panic("LedgerRepository.UpdateFunc: method is nil but LedgerRepository.Update was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}{
		Ctx:    ctx,
		Ledger: ledger,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, ledger)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedLedgerRepository.UpdateCalls())
func (mock *LedgerRepository) UpdateCalls() []struct {
	Ctx    context.Context
	Ledger *domain.Ledger
} {
	var calls []struct {
		Ctx    context.Context
		Ledger *domain.Ledger
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that Repositories does implement ports.Repositories.
// If this is not the case, regenerate this file with mockery.
var _ ports.LocalRepositories = &Repositories{}

// Repositories is a mock implementation of ports.Repositories.
//
//	func TestSomethingThatUsesRepositories(t *testing.T) {
//
//		// make and configure a mocked ports.Repositories
//		mockedRepositories := &Repositories{
//			ExpenseFunc: func() ports.ExpenseRepository {
//				panic("mock out the Expense method")
//			},
//			LedgerFunc: func() ports.LedgerRepository {
//				panic("mock out the Ledger method")
//			},
//			UserFunc: func() ports.UserRepository {
//				panic("mock out the User method")
//			},
//		}
//
//		// use mockedRepositories in code that requires ports.Repositories
//		// and then make assertions.
//
//	}
type Repositories struct {
	// ExpenseFunc mocks the Expense method.
	ExpenseFunc func() ports.ExpenseRepository

	// LedgerFunc mocks the Ledger method.
	LedgerFunc func() ports.LedgerRepository

	// UserFunc mocks the User method.
	UserFunc func() ports.UserRepository

	// calls tracks calls to the methods.
	calls struct {
		// Expense holds details about calls to the Expense method.
		Expense []struct {
		}
		// Ledger holds details about calls to the Ledger method.
		Ledger []struct {
		}
		// User holds details about calls to the User method.
		User []struct {
		}
	}
	lockExpense sync.RWMutex
	lockLedger  sync.RWMutex
	lockUser    sync.RWMutex
}

// Expense calls ExpenseFunc.
func (mock *Repositories) Expense() ports.ExpenseRepository {
	if mock.ExpenseFunc == nil {
		panic("Repositories.ExpenseFunc: method is nil but Repositories.Expense was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExpense.Lock()
	mock.calls.Expense = append(mock.calls.Expense, callInfo)
	mock.lockExpense.Unlock()
	return mock.ExpenseFunc()
}

// ExpenseCalls gets all the calls that were made to Expense.
// Check the length with:
//
//	len(mockedRepositories.ExpenseCalls())
func (mock *Repositories) ExpenseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExpense.RLock()
	calls = mock.calls.Expense
	mock.lockExpense.RUnlock()
	return calls
}

// Ledger calls LedgerFunc.
func (mock *Repositories) Ledger() ports.LedgerRepository {
	if mock.LedgerFunc == nil {
		panic("Repositories.LedgerFunc: method is nil but Repositories.Ledger was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLedger.Lock()
	mock.calls.Ledger = append(mock.calls.Ledger, callInfo)
	mock.lockLedger.Unlock()
	return mock.LedgerFunc()
}

// LedgerCalls gets all the calls that were made to Ledger.
// Check the length with:
//
//	len(mockedRepositories.LedgerCalls())
func (mock *Repositories) LedgerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLedger.RLock()
	calls = mock.calls.Ledger
	mock.lockLedger.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *Repositories) User() ports.UserRepository {
	if mock.UserFunc == nil {
		panic("Repositories.UserFunc: method is nil but Repositories.User was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc()
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedRepositories.UserCalls())
func (mock *Repositories) UserCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// Ensure that LocalDatabase does implement ports.LocalDatabase.
// If this is not the case, regenerate this file with mockery.
var _ ports.LocalDatabase = &LocalDatabase{}

// LocalDatabase is a mock implementation of ports.LocalDatabase.
//
//	func TestSomethingThatUsesLocalDatabase(t *testing.T) {
//
//		// make and configure a mocked ports.LocalDatabase
//		mockedLocalDatabase := &LocalDatabase{
//			ExpenseFunc: func() ports.ExpenseQueries {
//				panic("mock out the Expense method")
//			},
//			LedgerFunc: func() ports.LedgerQueries {
//				panic("mock out the Ledger method")
//			},
//			TransactionFunc: func(ctx context.Context, f func(tx ports.Repositories) error) error {
//				panic("mock out the Transaction method")
//			},
//			UserFunc: func() ports.UserQueries {
//				panic("mock out the User method")
//			},
//		}
//
//		// use mockedLocalDatabase in code that requires ports.LocalDatabase
//		// and then make assertions.
//
//	}
type LocalDatabase struct {
	// ExpenseFunc mocks the Expense method.
	ExpenseFunc func() ports.ExpenseQueries

	// LedgerFunc mocks the Ledger method.
	LedgerFunc func() ports.LedgerQueries

	// TransactionFunc mocks the Transaction method.
	TransactionFunc func(ctx context.Context, f func(tx ports.LocalRepositories) error) error

	// UserFunc mocks the User method.
	UserFunc func() ports.UserQueries

	// calls tracks calls to the methods.
	calls struct {
		// Expense holds details about calls to the Expense method.
		Expense []struct {
		}
		// Ledger holds details about calls to the Ledger method.
		Ledger []struct {
		}
		// Transaction holds details about calls to the Transaction method.
		Transaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// F is the f argument value.
			F func(tx ports.LocalRepositories) error
		}
		// User holds details about calls to the User method.
		User []struct {
		}
	}
	lockExpense     sync.RWMutex
	lockLedger      sync.RWMutex
	lockTransaction sync.RWMutex
	lockUser        sync.RWMutex
}

// Expense calls ExpenseFunc.
func (mock *LocalDatabase) Expense() ports.ExpenseQueries {
	if mock.ExpenseFunc == nil {
		panic("LocalDatabase.ExpenseFunc: method is nil but LocalDatabase.Expense was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExpense.Lock()
	mock.calls.Expense = append(mock.calls.Expense, callInfo)
	mock.lockExpense.Unlock()
	return mock.ExpenseFunc()
}

// ExpenseCalls gets all the calls that were made to Expense.
// Check the length with:
//
//	len(mockedLocalDatabase.ExpenseCalls())
func (mock *LocalDatabase) ExpenseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExpense.RLock()
	calls = mock.calls.Expense
	mock.lockExpense.RUnlock()
	return calls
}

// Ledger calls LedgerFunc.
func (mock *LocalDatabase) Ledger() ports.LedgerQueries {
	if mock.LedgerFunc == nil {
		panic("LocalDatabase.LedgerFunc: method is nil but LocalDatabase.Ledger was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLedger.Lock()
	mock.calls.Ledger = append(mock.calls.Ledger, callInfo)
	mock.lockLedger.Unlock()
	return mock.LedgerFunc()
}

// LedgerCalls gets all the calls that were made to Ledger.
// Check the length with:
//
//	len(mockedLocalDatabase.LedgerCalls())
func (mock *LocalDatabase) LedgerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLedger.RLock()
	calls = mock.calls.Ledger
	mock.lockLedger.RUnlock()
	return calls
}

// Transaction calls TransactionFunc.
func (mock *LocalDatabase) Transaction(ctx context.Context, f func(tx ports.LocalRepositories) error) error {
	if mock.TransactionFunc == nil {
		panic("LocalDatabase.TransactionFunc: method is nil but LocalDatabase.Transaction was just called")
	}
	callInfo := struct {
		Ctx context.Context
		F   func(tx ports.LocalRepositories) error
	}{
		Ctx: ctx,
		F:   f,
	}
	mock.lockTransaction.Lock()
	mock.calls.Transaction = append(mock.calls.Transaction, callInfo)
	mock.lockTransaction.Unlock()
	return mock.TransactionFunc(ctx, f)
}

// TransactionCalls gets all the calls that were made to Transaction.
// Check the length with:
//
//	len(mockedLocalDatabase.TransactionCalls())
func (mock *LocalDatabase) TransactionCalls() []struct {
	Ctx context.Context
	F   func(tx ports.LocalRepositories) error
} {
	var calls []struct {
		Ctx context.Context
		F   func(tx ports.LocalRepositories) error
	}
	mock.lockTransaction.RLock()
	calls = mock.calls.Transaction
	mock.lockTransaction.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *LocalDatabase) User() ports.UserQueries {
	if mock.UserFunc == nil {
		panic("LocalDatabase.UserFunc: method is nil but LocalDatabase.User was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc()
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedLocalDatabase.UserCalls())
func (mock *LocalDatabase) UserCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// Ensure that UserQueries does implement ports.UserQueries.
// If this is not the case, regenerate this file with mockery.
var _ ports.UserQueries = &UserQueries{}

// UserQueries is a mock implementation of ports.UserQueries.
//
//	func TestSomethingThatUsesUserQueries(t *testing.T) {
//
//		// make and configure a mocked ports.UserQueries
//		mockedUserQueries := &UserQueries{
//			GetFunc: func(ctx context.Context, id domain.ID) (*domain.User, error) {
//				panic("mock out the Get method")
//			},
//			GetByEmailFunc: func(ctx context.Context, email string) (*domain.User, error) {
//				panic("mock out the GetByEmail method")
//			},
//			ListByEmailFunc: func(ctx context.Context, emails []string) ([]domain.User, error) {
//				panic("mock out the ListByEmail method")
//			},
//		}
//
//		// use mockedUserQueries in code that requires ports.UserQueries
//		// and then make assertions.
//
//	}
type UserQueries struct {
	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id domain.ID) (*domain.User, error)

	// GetByEmailFunc mocks the GetByEmail method.
	GetByEmailFunc func(ctx context.Context, email string) (*domain.User, error)

	// ListByEmailFunc mocks the ListByEmail method.
	ListByEmailFunc func(ctx context.Context, emails []string) ([]domain.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// GetByEmail holds details about calls to the GetByEmail method.
		GetByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// ListByEmail holds details about calls to the ListByEmail method.
		ListByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Emails is the emails argument value.
			Emails []string
		}
	}
	lockGet         sync.RWMutex
	lockGetByEmail  sync.RWMutex
	lockListByEmail sync.RWMutex
}

// Get calls GetFunc.
func (mock *UserQueries) Get(ctx context.Context, id domain.ID) (*domain.User, error) {
	if mock.GetFunc == nil {
		panic("UserQueries.GetFunc: method is nil but UserQueries.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedUserQueries.GetCalls())
func (mock *UserQueries) GetCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetByEmail calls GetByEmailFunc.
func (mock *UserQueries) GetByEmail(ctx context.Context, email string) (*domain.User, error) {
	if mock.GetByEmailFunc == nil {
		panic("UserQueries.GetByEmailFunc: method is nil but UserQueries.GetByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetByEmail.Lock()
	mock.calls.GetByEmail = append(mock.calls.GetByEmail, callInfo)
	mock.lockGetByEmail.Unlock()
	return mock.GetByEmailFunc(ctx, email)
}

// GetByEmailCalls gets all the calls that were made to GetByEmail.
// Check the length with:
//
//	len(mockedUserQueries.GetByEmailCalls())
func (mock *UserQueries) GetByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetByEmail.RLock()
	calls = mock.calls.GetByEmail
	mock.lockGetByEmail.RUnlock()
	return calls
}

// ListByEmail calls ListByEmailFunc.
func (mock *UserQueries) ListByEmail(ctx context.Context, emails []string) ([]domain.User, error) {
	if mock.ListByEmailFunc == nil {
		panic("UserQueries.ListByEmailFunc: method is nil but UserQueries.ListByEmail was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Emails []string
	}{
		Ctx:    ctx,
		Emails: emails,
	}
	mock.lockListByEmail.Lock()
	mock.calls.ListByEmail = append(mock.calls.ListByEmail, callInfo)
	mock.lockListByEmail.Unlock()
	return mock.ListByEmailFunc(ctx, emails)
}

// ListByEmailCalls gets all the calls that were made to ListByEmail.
// Check the length with:
//
//	len(mockedUserQueries.ListByEmailCalls())
func (mock *UserQueries) ListByEmailCalls() []struct {
	Ctx    context.Context
	Emails []string
} {
	var calls []struct {
		Ctx    context.Context
		Emails []string
	}
	mock.lockListByEmail.RLock()
	calls = mock.calls.ListByEmail
	mock.lockListByEmail.RUnlock()
	return calls
}

// Ensure that UserCommands does implement ports.UserCommands.
// If this is not the case, regenerate this file with mockery.
var _ ports.UserCommands = &UserCommands{}

// UserCommands is a mock implementation of ports.UserCommands.
//
//	func TestSomethingThatUsesUserCommands(t *testing.T) {
//
//		// make and configure a mocked ports.UserCommands
//		mockedUserCommands := &UserCommands{
//			CreateFunc: func(ctx context.Context, user *domain.User) error {
//				panic("mock out the Create method")
//			},
//		}
//
//		// use mockedUserCommands in code that requires ports.UserCommands
//		// and then make assertions.
//
//	}
type UserCommands struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, user *domain.User) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User *domain.User
		}
	}
	lockCreate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *UserCommands) Create(ctx context.Context, user *domain.User) error {
	if mock.CreateFunc == nil {
		panic("UserCommands.CreateFunc: method is nil but UserCommands.Create was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User *domain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, user)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedUserCommands.CreateCalls())
func (mock *UserCommands) CreateCalls() []struct {
	Ctx  context.Context
	User *domain.User
} {
	var calls []struct {
		Ctx  context.Context
		User *domain.User
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Ensure that UserRepository does implement ports.UserRepository.
// If this is not the case, regenerate this file with mockery.
var _ ports.UserRepository = &UserRepository{}

// UserRepository is a mock implementation of ports.UserRepository.
//
//	func TestSomethingThatUsesUserRepository(t *testing.T) {
//
//		// make and configure a mocked ports.UserRepository
//		mockedUserRepository := &UserRepository{
//			CreateFunc: func(ctx context.Context, user *domain.User) error {
//				panic("mock out the Create method")
//			},
//			GetFunc: func(ctx context.Context, id domain.ID) (*domain.User, error) {
//				panic("mock out the Get method")
//			},
//			GetByEmailFunc: func(ctx context.Context, email string) (*domain.User, error) {
//				panic("mock out the GetByEmail method")
//			},
//			ListByEmailFunc: func(ctx context.Context, emails []string) ([]domain.User, error) {
//				panic("mock out the ListByEmail method")
//			},
//		}
//
//		// use mockedUserRepository in code that requires ports.UserRepository
//		// and then make assertions.
//
//	}
type UserRepository struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, user *domain.User) error

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id domain.ID) (*domain.User, error)

	// GetByEmailFunc mocks the GetByEmail method.
	GetByEmailFunc func(ctx context.Context, email string) (*domain.User, error)

	// ListByEmailFunc mocks the ListByEmail method.
	ListByEmailFunc func(ctx context.Context, emails []string) ([]domain.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User *domain.User
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID domain.ID
		}
		// GetByEmail holds details about calls to the GetByEmail method.
		GetByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// ListByEmail holds details about calls to the ListByEmail method.
		ListByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Emails is the emails argument value.
			Emails []string
		}
	}
	lockCreate      sync.RWMutex
	lockGet         sync.RWMutex
	lockGetByEmail  sync.RWMutex
	lockListByEmail sync.RWMutex
}

// Create calls CreateFunc.
func (mock *UserRepository) Create(ctx context.Context, user *domain.User) error {
	if mock.CreateFunc == nil {
		panic("UserRepository.CreateFunc: method is nil but UserRepository.Create was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User *domain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, user)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedUserRepository.CreateCalls())
func (mock *UserRepository) CreateCalls() []struct {
	Ctx  context.Context
	User *domain.User
} {
	var calls []struct {
		Ctx  context.Context
		User *domain.User
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *UserRepository) Get(ctx context.Context, id domain.ID) (*domain.User, error) {
	if mock.GetFunc == nil {
		panic("UserRepository.GetFunc: method is nil but UserRepository.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  domain.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedUserRepository.GetCalls())
func (mock *UserRepository) GetCalls() []struct {
	Ctx context.Context
	ID  domain.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  domain.ID
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetByEmail calls GetByEmailFunc.
func (mock *UserRepository) GetByEmail(ctx context.Context, email string) (*domain.User, error) {
	if mock.GetByEmailFunc == nil {
		panic("UserRepository.GetByEmailFunc: method is nil but UserRepository.GetByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetByEmail.Lock()
	mock.calls.GetByEmail = append(mock.calls.GetByEmail, callInfo)
	mock.lockGetByEmail.Unlock()
	return mock.GetByEmailFunc(ctx, email)
}

// GetByEmailCalls gets all the calls that were made to GetByEmail.
// Check the length with:
//
//	len(mockedUserRepository.GetByEmailCalls())
func (mock *UserRepository) GetByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetByEmail.RLock()
	calls = mock.calls.GetByEmail
	mock.lockGetByEmail.RUnlock()
	return calls
}

// ListByEmail calls ListByEmailFunc.
func (mock *UserRepository) ListByEmail(ctx context.Context, emails []string) ([]domain.User, error) {
	if mock.ListByEmailFunc == nil {
		panic("UserRepository.ListByEmailFunc: method is nil but UserRepository.ListByEmail was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Emails []string
	}{
		Ctx:    ctx,
		Emails: emails,
	}
	mock.lockListByEmail.Lock()
	mock.calls.ListByEmail = append(mock.calls.ListByEmail, callInfo)
	mock.lockListByEmail.Unlock()
	return mock.ListByEmailFunc(ctx, emails)
}

// ListByEmailCalls gets all the calls that were made to ListByEmail.
// Check the length with:
//
//	len(mockedUserRepository.ListByEmailCalls())
func (mock *UserRepository) ListByEmailCalls() []struct {
	Ctx    context.Context
	Emails []string
} {
	var calls []struct {
		Ctx    context.Context
		Emails []string
	}
	mock.lockListByEmail.RLock()
	calls = mock.calls.ListByEmail
	mock.lockListByEmail.RUnlock()
	return calls
}
